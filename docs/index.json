[
{
	"uri": "https://maarteng18.github.io/notes/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Maarten\u0026rsquo;s notes Current courses Databases Algoritmen en datastructuren Regeltechniek Cloud computing \u0026amp; toepassingen Objectgeoriënteerd programmeren Good to know I\u0026rsquo;m currently making a portfolio, more coming soon!\nSome usefull commands ImageMagick "
},
{
	"uri": "https://maarteng18.github.io/notes/christmas/",
	"title": "Christmas",
	"tags": [],
	"description": "",
	"content": "Subjects Christmas "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/",
	"title": "Current Courses",
	"tags": [],
	"description": "",
	"content": "Current courses Databases Algoritmen en datastructuren Regeltechniek Cloud computing \u0026amp; toepassingen Objectgeoriënteerd programmeren "
},
{
	"uri": "https://maarteng18.github.io/notes/scripts-commands/",
	"title": "Scripts &amp; commands",
	"tags": [],
	"description": "",
	"content": "Subjects ImageMagick Markdown "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/algoritmen-en-datastructuren/",
	"title": "Algoritmen en datastructuren",
	"tags": [],
	"description": "",
	"content": "Chapters Week 1 Week 2 Week 3 Week 4 Week 5 Week 6 "
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/",
	"title": "Analoge Elektronische Schakelingen",
	"tags": [],
	"description": "",
	"content": "Chapters Herhaling MOSFET en BJT "
},
{
	"uri": "https://maarteng18.github.io/notes/archive/",
	"title": "Archive",
	"tags": [],
	"description": "",
	"content": "2nd Bachelor of Science Analoge Elektronische Schakelingen Digitale Elektronische Schakelingen Android App Development Besturingssystemen en C Software Engineering Skills "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/cct/",
	"title": "Cloud Computing &amp; toepassingen",
	"tags": [],
	"description": "",
	"content": " Week 1 "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/databases/",
	"title": "Databases",
	"tags": [],
	"description": "",
	"content": "Chapters Week 1 Week 2-3 Week 4 "
},
{
	"uri": "https://maarteng18.github.io/notes/archive/disch/",
	"title": "Digitale Elektronische Schakelingen",
	"tags": [],
	"description": "",
	"content": "Chapters Inleiding Programmeerbare logica Geheugens Ontwerpprincipes voor synchrone logica Simulatie Zelfstudie VHDL Zelfstudie FSM "
},
{
	"uri": "https://maarteng18.github.io/notes/scripts-commands/imagemagick/",
	"title": "Image Magick",
	"tags": [],
	"description": "",
	"content": "Subjects Montage "
},
{
	"uri": "https://maarteng18.github.io/notes/scripts-commands/markdown/",
	"title": "Markdown",
	"tags": [],
	"description": "",
	"content": "Subjects Notices "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/obj/",
	"title": "Objectgeoriënteerd programmeren",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/courses/regeltechniek/",
	"title": "Regeltechniek",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-1/",
	"title": "1. Herhaling MOSFET en BJT",
	"tags": [],
	"description": "",
	"content": "MOSFET Werking MOS transistor De MOS transistor bestaat uit: een gate gemaakt uit polykristallijn Si boven op een heel dun oxide dat op het Si neergelegd is. een source en een drain die geïmplementeerd zijn a.d.h.v. een pn-junctie gescheiden van de bulk. Wanneer er een spanning aangelegd wordt aan de gate: Eerst zorgen dat ladingsdragers van de bulk, die van een tegengesteld type zijn dan de gewenste ladingsdragers, voldoende ver van onder de gate verdwijnen. BJT "
},
{
	"uri": "https://maarteng18.github.io/notes/archive/disch/ch-1/",
	"title": "1. Inleiding",
	"tags": [],
	"description": "",
	"content": "Table of contents Herhaling implementatieplatformen FPGA vs. microprocessor Codevoorbeeld Herhaling implementatieplatformen Discrete logica: digitale schakelingen opgebouwd met bijvoorbeeld chips uit de 74-reeks.\nMicroprocessor: vaste hardware waarop software wordt uitgevoerd, zoals bijvoorbeeld de ATmega328-processor op het Arduino Uno-bord.\nASIC (Application Specific Integrated Circuit): vaste hardware met een specifieke functie.\nFPGA (Field-Programmable Gate Array): configureerbare hardware met een regelmatige structuur, waarop specifieke functies geïmplementeerd kunnen worden.\nFPGA vs. microprocessor FPGA Bouwblokken van de FPGA CLB: Configurable Logic Block SM: Switch Matrix IOB: Input/Output Block Basisblokken van een CLB FF: Flip-Flop Mutex: Multiplexer LUT: Look-Up Table Kan geconfigureerd worden tot eender welke functie met 4 ingangen en 1 uitgang. Microprocessor De CPU is het hart van een microprocessor en bevat o.a.:\nALU: Arithmatic Logic Unit Register file Programmageheugen Codevoorbeeld We beschouwen een stukje code in een hardwarebeschrijvingstaal (VHDL) en in een programmeertaal (C).\nHet input-outputgedrag van de implementatie is functioneel hetzelfde. De implementatie gebeurt op een volledig andere manier op een FPGA dan op de microprocessor In zowel VHDL als C zijn a en z bytes, in VHDL is sel een bit en in C is sel een byte if sel = \u0026#39;1\u0026#39; then z \u0026lt;= a sll 1; else z \u0026lt;= a srl 1; end if; if((sel \u0026amp; 0x01) == 1) { z = a \u0026lt;\u0026lt; 1; } else { z = a \u0026gt;\u0026gt; 1; } Beide codefragmenten implementeren een schuifbewerking naar links als de selectiebit gelijk is aan 1 en anders een schuifbewerking naar rechts. Dus ofwel wordt:\nz7z6z5z4z3z2z1z0 = a6a5a4a3a2a1a00 (links) z7z6z5z4z3z2z1z0 = 0a7a6a5a4a3a2a1 (rechts) VHDL → FPGA Er zijn er 2 hardware equivalenten van toepassing:\nEen schuifbewerking is het verbinden van in- en uitgangen met elkaar op een verschoven manier. Kiezen tussen 2 mogelijke waarden op basis van een selectiebit is een multiplexer Hiervoor zijn 8 multiplexers nodig om de 8 bits van z aan te sturen. Om dit op een FPGA te configureren zullen er dus 8 LUT\u0026rsquo;s gebruikt worden zonder FF.\nDe 6 middenste LUT\u0026rsquo;s implementeren een multiplexer. De bovenste en onderste LUT\u0026rsquo;s implementeren een functie die ofwel 0 ofwel de inkomende ai doorlaat op basis van de selectiebit. De LUT\u0026rsquo;s in de CLB\u0026rsquo;s worden verbonden met de juiste in- en uitgangen via Switch Matrices.\nDe LUT\u0026rsquo;s zijn op onderstaande manier geconfigureerd:\nBovenste LUT = bovenste multiplexer: A B C D LUT-out 0 0 x x 0 0 1 x x 0 1 0 x x 1 1 1 x x 0 Middelste LUT (6x) = middelste multiplexer (6x) A B C D LUT-out 0 0 0 x 0 0 0 1 x 0 0 1 0 x 1 0 1 1 x 0 1 0 0 x 0 1 0 1 x 1 1 1 0 x 1 1 1 1 x 1 Onderste LUT = onderster multiplexer A B C D LUT-out 0 0 x x 0 0 1 x x 0 1 0 x x 0 1 1 x x 1 C → microprocessor Het schuiven van bits in een microprocessor gebeurt in de ALU via een schuifbewerking. De schuifinstructies met bijhorende machinecode zien er als volgt uit:\nLogical Shift Left (LSL): De byte op adres Rd = ddddd wordt 1 bit naar links geschoven en daarna terug geschreven op hetzelfde adres. De opcode komt overeen met een optelling van 2 dezelfde getallen. Logical Shift Right (LSR): De byte op adres Rd = ddddd wordt 1 bit naar rechts geschoven en daarna terug geschreven op hetzelde adres. Het controleren of een byte gelijk is aan een constante waarde gebeurt in de ALU via een aftrekking. Als die aftrekking in 0 resulteert, is de byte gelijk aan de constante waarde en anders niet. De zero-flag aan de uitgang van de ALU geeft dus het resultaat weer. Een volgende instructie kan dan de zero-flag controleren om te kiezen tussen de volgende instructie in het programmageheugen of een instructie ergens anders in het programmageheugen.\nCompare with Immediate (CPI): De Waarde KKKKKKKK wordt afgetrokken van de byte op adres Rd = 1dddd; waarbij de zero-flag al dan niet 1 wordt. Branch if Equal (BREQ): Als de zero-flag gelijk is aan 0, springt de program counter 1 plaats verder. Als de zero-flag gelijk is aan 1, springt de program counter kkkkkkk+1 plaatsen verder. Vermits we alle bewerkingen op bytes uitvoeren, moeten we een bit isoleren uit een byte om met 1 selectiebit te werken. We gebruiken een bitmask om 1 bit te selecteren. Dat doen we door een AND-bewerking uit te voeren met een constante byte die uit zeven 0-en en één 1 bestaat. De plaats van de 1 bepaalt welke bit we willen gebruiken.\nIn dit voorbeeld zouden het programmageheugen, de register file en de zero-flag er als volgt kunnen uitzien:\nProgrammageheugen 0 0111000001000001 ANDI r20, 1 1 0011000001000001 CPI r20, 1 2 1111000000011001 BREQ 3 3 1001010000000110 LSR r0 \u0026hellip; 6 0000110000000000 LSL r0 Geef aan hoe onderstaand codevoorbeeld kan omgezet worden in een implementatie op een FPGA en een microprocessor, waarbij c, d en z bytes zijn en waarbij sel een bit is in de VHDL-code en een byte is in C-code. Geeft aan hoe de LUT\u0026rsquo;s geconfigureerd zijn in de FPGA-implementatie. Geef aan wat er in het programmageheugen en de register file zit in de microprocessorimplementatie. Gebruik de AVR-instructieset om de gepaste instructies te vinden. if sel = \u0026#39;1\u0026#39; then z \u0026lt;= c and d; else z \u0026lt;= c or d; end if; if((sel \u0026amp; 0x80) == 0x80) { z = c \u0026amp; d; } else { z = c | d; } "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/databases/week-1/",
	"title": "1. week 1",
	"tags": [],
	"description": "",
	"content": "RDBMS Database Basics ISBN is een string omdat er niet mee gerekend moet worden. Alles waar niet mee gerekend moet worden, wordt als string opgeslaan in een database.\nLaatste mermaid:\nPijltje author naar author detail, 1 wil zeggen een boek heeft 1 author en 1\u0026hellip;* zegt dat een author meerdere boeken kan hebben.\nDatabase Componenten Excel bestand in orde maken en library.db bekijken voor te zien hoe het werkt.\n"
},
{
	"uri": "https://maarteng18.github.io/notes/courses/obj/week-2/",
	"title": "1. week 2",
	"tags": [],
	"description": "",
	"content": "Opdrachten Hoofdstuk 1-4 1.2.1 ✔️\n1.2.2 ✔️\n1.2.3 ✔️\n1.2.4 ✔️\n1.2.5 Welke voordelen biedt een klasse als Date ten opzichte van een datum steeds voor te stellen als drie aparte getallen? Zo is het vaak beter om bijvoorbeeld een positie of grootte niet steeds voor te stellen door twee getallen, maar door (heel eenvoudige) klassen of structures. Op die manier wordt code tevens duidelijker. Vergelijk de method drawRect(int, int, int, int) maar met drawRect(Point, Point) of drawRect(Point, Size).\nDe verleiding is soms ook groot om allerlei gegevens op te slaan of door te geven als std::string. Bij gestructureerde gegevens, zoals een datum, is een klasse zoals Date vaak de betere oplossing. Kun je uitleggen waarom?\nSinds C++20 vind je in het \u0026lt;chrono\u0026gt; headerbestand klassen terug om een datum voor te stellen, analoog aan jouw Date klasse uit opdracht 1.2.4. Je vindt er zelfs klassen als day en year: wat is hun nut?\nOok in de Boost C++ Libraries vind je zulke klassen terug. Zoek deze eens op in de documentatie. Gebruik dergelijke libraries om het werk te verlichten!\nDoor de klasse ´Date´ te maken kunnen er complexe methodes achtergehouden worden die controleren als de datum geldig is. Indien er geen klasse is moeten deze methodes altijd opnieuw geïmplementeerd worden en dit zal zorgen voor onduidelijke en moeilijke code.\nDoor ´Date´ op deze manier voor te stellen wordt de notatievolgorde niet meer belangrijk waardoor er geen rekenfouten gemaakt kunnen worden.\n1.2.6 📋 Methode maken voor het controleren welke datum het grootste is\n"
},
{
	"uri": "https://maarteng18.github.io/notes/archive/disch/ch-2/",
	"title": "2. Progammeerbare logica",
	"tags": [],
	"description": "",
	"content": "Table of contents Overzicht programmeerbare componenten FPGA-technologie Overzicht programmeerbare componenten Programmeerbare verbindingen Fuse:\nGesloten verbinding, opent onder grote stroom OTP (One-Time Programmable) Antifuse:\nOpen verbinding, sluit onder hoge spanning OTP SRAM-gebaseerde verbinding:\nPass transistors gecontroleerd door SRAM Volledig CMOS gebaseerd (E)EPROM-gebaseerd:\nFAMOS EPROM technologie (UV- erasable) FLOTOX EEPROM technologie Flash technologie Programmeerbare componenten (Simple) Programmable Logic Device ((S)PLD): Programmable Logic Array (PLA) Programmable Array Logic (PAL) Programmable Read Only Memory (PROM, EPROM, EEPROM) Complex PLD (CPLD) Field Programmable Gate Array (FPGA) SPLD Elke functie kan geraliseerd worden in een \u0026ldquo;Sum Of Products\u0026rdquo; (SOP) vorm. Een SOP vorm kan gerealiseerd worden door INV/AND/OR (of INV/NAND/NAND) De AND/OR gates zijn vooraf gemaakt. Programmeren gebeurt door het maken of verbreken van connecties tussen gates. PLA: Zowel AND als OR arrays zijn programmeerbaar PAL: AND array is programmeerbaar OR arry is vast PROM: Alle mogelijkheden zijn voorzien PLA Gemeenschappelijk gebruik van producttermen Voorbeeld: F0 = A + B\u0026rsquo;C' F1 = AC\u0026rsquo; + AB F2 = B\u0026rsquo;C + AB F3 = B\u0026rsquo;C + A Alle Mogelijke verbindingen zijn beschikbaar voor het programmeren: De niet-gewenste verbindingen worden opgeblazen Sommige technologieën maken verbindingen i.p.v. ze op te blazen.\nConventies PLA\nOm het aantal lijnen te verminderen tekenen we de verschillende ingangen op 1 lijn. Elke ingang wordt geïnverteerd zodat we zowel de niet-geïnverteerde ingang als de geïnverteerde ingang kunnen gebruiken. Voorstelling PLA\nPLA-voorstelling waarbij alle verbindingen gemaakt zijn. PLA-voorstelling voor de implementatie: F0 = AB + A\u0026rsquo;B' F1 = CD\u0026rsquo; + C\u0026rsquo;D Verschil tussen PLA en PAL PAL: OR verbindingen zijn vast\nDe volgorde van de AND termen moeten zo gekozen worden dat ze overeenkomen met de verbindingen in de OR matrix. De AND termen zijn niet herbruikbaar. Dit leidt tot een grotere matrix. Het aantal AND termen per OR is beperkt. Niet alle functies zijn implementeeraar. Enkel het AND vlak moet geprogrammeerd worden. PLA:\nZowel AND als OR verbindingen zijn programmeerbaar. De AND termen zijn herbruikbaar. Zowel het AND als het OR vlak moeten geprogrammeerd worden. Teken een PLA waarin de volgende functies geprogrammeerd zijn: Z1 = A xor B xor C Z2 = A and (B xnor C) 2-1 multiplexer Hoe ziet een PAL eruit waarin deze functies geprogrammeerd zijn? ROM als PLD In tegenstelling tot een PLA is een ROM een structuur met een volledig gecodeerde AND array. Elke mogelijkheid tot het samen nemen van ingangen (adreslijnen) zit erin. Wat is de inhoud van een ROM-geheugen dat de volgende functies realiseert:\nZ1 = A xor B xor C Z2 = A and (B xnor C) 2-1 multiplexer CPLD CPLD = Complex Programmable Logic Device Een CPLD bestaat uit verschillende logische blokken die elk equivalent zijn met een (S)PLD. Deze (S)PLDs worden met elkaar verbonden via een Programmable Interconnect Matrix (PIM). Op deze manier wordt het Si-oppervlak nuttiger gebruikt in vergelijking met een grote PLD. Algemene structuur:\nFPGA-technologie FPGA = Field Programmable Gate Array Array van logische cellen die met elkaar en met de I/O cellen kunnen communiceren Horizontale en verticale verbindingen. FPGA architectuur IOB: Input/Output Block CLB: Configurable Logic Block SM: Switch Matrix Vergelijking CPLD en FPGA CPLD Continue interconnect Verbindingen hebben een vaste vertraging FPGA Gesegmenteerde verbindingen Verbindingen hebben een onvoorspelbare vertraging. Basisbouwblokken in een CLB Basisprincipe van een SM Evolutie van Xilinx FPGA\u0026rsquo;s Configuratie van FPGA\u0026rsquo;s Configuratiedata: bitstream Configuratiegeheugen: (Anti-)fuse: one-time programmable (OTP) Flash: niet-vluchtig SRAM: vluchtig SRAM (vs. flash) configuratiegeheugen: Hogere dichtheid Hoger vermogenverbruik On-board of on-chip niet-vluchtig geheugen nodig om de bitsream op te slaan tijdens power-off Hogere configuratiesnelheid Configuratie van een CLB Configuratiebits Waarom 16 configuratiebits voor een 4-naar-1 LUT?\n216 mogelijke output functies: Z0 = 0 Z1 = A\u0026rsquo;.B\u0026rsquo;.C\u0026rsquo;.D' Z2 = A\u0026rsquo;.B\u0026rsquo;.C\u0026rsquo;.D Z3 = A\u0026rsquo;.B\u0026rsquo;.C' \u0026hellip; Z65280 = A \u0026hellip; Z65535 = 1 A B C D Z0 Z1 Z2 Z3 \u0026hellip; Z65280 \u0026hellip; Z65535 0 0 0 0 0 1 0 1 0 1 0 0 0 1 0 0 1 1 0 1 0 0 1 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 1 1 1 0 1 0 0 0 0 0 1 1 1 0 1 1 0 0 0 0 1 1 1 1 0 0 0 0 0 0 1 1 1 1 0 1 0 0 0 0 1 1 1 1 1 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 1 1 Configuratie van een SM Ontwerp van een digitaal systeem op FPGA Beschrijving van het ontwerp Schematische invoer Invoer via HDL (Hardware Description Language) VHDL (VHSIC HDL) VHSIC = Very High Speed Integrated Circuit Verilog Implementatie van het systeem Bitsream met configuratie-gegevens Na synthese en place \u0026amp; route Inladen van de bitstream Via download kabel (parallel, USB) verbonden met PC Vanuit on-board ROM Ontwerp m.b.v. VHDL Platform-onafhankelijke code Bruikbaar voor alle FPGA\u0026rsquo;s Bruikbaar voor ASIC standaardcel ontwerp Platform-specifiek code Geoptimaliseerd voor een specifiek FPGA Gebruikmakend van specifieke compenenten in een FPGA Bv.: multiplexers, block RAM\u0026hellip; FPGA vendors AMD (Xilinx) en Intel: SRAM-gebaseerde FPGA\u0026rsquo;s Meer dan 2/3 van de FPGA markt Microchip (Microsemi): Flash-gebaseerde FPGA\u0026rsquo;s Specifieke marktsector voor toepassingen met hoge betrouwbaarheid, databeveiliging, laag vermogenverbruik Lattice en Quicklogic: Laag vermogenverbruik Specifieke functionaliteit "
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-2/",
	"title": "2. Transistor configuraties",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/courses/databases/week-2-3/",
	"title": "2. week 2-3",
	"tags": [],
	"description": "",
	"content": " Schrijf een query die alle Customers (volledige naam, customer ID en land) laat zien die niet wonen in de USA. SELECT * FROM customers WHERE Country != \u0026#39;USA\u0026#39; SELECT * FROM customers WHERE Country \u0026lt;\u0026gt; \u0026#39;USA\u0026#39; Schrijf een query die enkel de Customers laat zien die in Brazilië wonen. SELECT * FROM customers WHERE Country = \u0026#39;Brazil\u0026#39;; Schrijf een query die alle Employees laat zien die werken in de Sales afdeling. SELECT * FROM employees WHERE Title like \u0026#39;Sales%\u0026#39;; Schrijf een query die een unieke lijst van landen laat zien uit de Invoices tabel. SELECT DISTINCT BillingCountry FROM invoices; Schrijf een query die alle Tracks laat zien waarvoor er geen componist bekend is. SELECT * FROM tracks WHERE Composer is NULL; Schrijf een query van alle unieke Componisten. Als de componist niet bekend is, dan moet er ‘Onbekend’ weergegeven worden gesorteerd op naam. SELECT * FROM tracks WHERE Composer is NULL; Schrijf een query die het maximumbedrag van een Invoice laat zien. SELECT MAX(total) FROM invoices; Schrijf een query die alle Invoices laat zien van alle Customers uit Brazilië. Het resultaat moet de volledige naam van de Customer, Invoice ID, Invoice Datum en Billing Country weergeven. SELECT FirstName, LastName, InvoiceId, InvoiceDate, BillingCountry FROM invoices INNER JOIN customers ON customers.CustomerId = invoices.CustomerId WHERE customers.Country = \u0026#39;Brazil\u0026#39;; Schrijf een query die alle Invoices laat zien voor elke Sales Agent. Het resultaat moet de volledige naam van de Sales Agent weergeven. SELECT employees.FirstName, employees.LastName, invoices.* FROM invoices INNER JOIN customers ON customers.CustomerId = invoices.CustomerId INNER JOIN employees ON employees.EmployeeId = customers.SupportRepId Schrijf een query die het Invoice Totaal, de Customer naam en land en de naam van de Sales Agent weergeeft voor alle Invoices en Customers. SELECT invoices.Total, customers.FirstName, customers.LastName, customers.Country, employees.FirstName, employees.LastName FROM invoices INNER JOIN customers ON customers.CustomerId = invoices.CustomerId INNER JOIN employees ON employees.EmployeeId = customers.SupportRepId; Schrijf een query die het aantal invoice lijnen weergeeft voor Invoice ID 37. SELECT invoices.InvoiceId, invoice_items.* FROM invoice_items INNER JOIN invoices ON invoices.InvoiceId = invoice_items.InvoiceId WHERE invoices.InvoiceId = 37; Schrijf een query die de track naam weergeeft langs elke invoice lijn. SELECT invoice_items.InvoiceLineId, tracks.Name from tracks INNER JOIN invoice_items ON invoice_items.TrackId = tracks.TrackId; Schrijf een query die de track naam en de artiest naam weergeeft langs elke invoice lijn. Schrijf een query die alle tracks laat zien, maar geen ID’s. Het resultaat moet de album titel, het media type en het genre bevatten. Schrijf een query die alle genres weergeeft waarvoor er geen tracks bestaan. Schrijf een query die het aantal Invoices laat zien voor 2009 en 2011. SELECT strftime(\u0026#39;%Y\u0026#39;, invoices.InvoiceDate), count(*) from invoices WHERE strftime(\u0026#39;%Y\u0026#39;, invoices.InvoiceDate) in (\u0026#39;2009\u0026#39;, \u0026#39;2011\u0026#39;) GROUP BY strftime(\u0026#39;%Y\u0026#39;, invoices.InvoiceDate); Schrijf een query die het aantal invoices per land laat zien. SELECT BillingCountry, count(*) FROM invoices GROUP BY BillingCountry; Schrijf een query die per Invoice ID het aantal invoice lijnen laat zien. SELECT InvoiceId, count(*) FROM invoice_items GROUP BY InvoiceId; Schrijf een query die de naam van elke playlist laat zien, alsook het aantal tracks in elke playlist. SELECT Name, count(*) FROM playlists INNER JOIN playlist_track ON playlists.PlaylistId = playlist_track.PlaylistId GROUP BY playlists.PlaylistId; Schrijf een query die alle data uit de Invoices tabel laat zien, aangevuld met het aantal invoice lijnen. SELECT invoices.*, count(*) FROM invoices INNER JOIN invoice_items ON invoices.InvoiceId = invoice_items.InvoiceId GROUP BY invoices.InvoiceId Schrijf een query die de totale verkoopcijfers per Sales Agent laat zien. SELECT employees.FirstName, employees.LastName, sum(invoices.total) FROM invoices INNER JOIN customers ON customers.CustomerId = invoices.CustomerId INNER JOIN employees ON employees.EmployeeId = customers.SupportRepId GROUP BY employees.LastName; Schrijf een query die laat zien welke Sales Agent de grootste verkoopcijfers heeft voor 2009. SELECT employees.FirstName, employees.LastName, sum(invoices.total) FROM invoices INNER JOIN customers ON customers.CustomerId = invoices.CustomerId INNER JOIN employees ON employees.EmployeeId = customers.SupportRepId GROUP BY employees.LastName HAVING strftime(\u0026#39;%Y\u0026#39;, invoices.InvoiceDate) in (\u0026#39;2009\u0026#39;) ORDER BY sum(invoices.total) DESC LIMIT 1 Schrijf een query die laat zien welke Sales Agent de grootste verkoopcijfers heeft voor 2010. SELECT employees.FirstName, employees.LastName, sum(invoices.total) FROM invoices INNER JOIN customers ON customers.CustomerId = invoices.CustomerId INNER JOIN employees ON employees.EmployeeId = customers.SupportRepId GROUP BY employees.LastName HAVING strftime(\u0026#39;%Y\u0026#39;, invoices.InvoiceDate) in (\u0026#39;2010\u0026#39;) ORDER BY sum(invoices.total) DESC LIMIT 1 Schrijf een query die laat zien welke Sales Agent de grootste verkoopcijfers heeft over alle jaren heen. SELECT employees.FirstName, employees.LastName, sum(invoices.total) FROM invoices INNER JOIN customers ON customers.CustomerId = invoices.CustomerId INNER JOIN employees ON employees.EmployeeId = customers.SupportRepId GROUP BY employees.LastName ORDER BY sum(invoices.total) DESC LIMIT 1 Schrijf een query die het aantal Customers laat zien per Sales Agent.\nSchrijf een query die alle invoices laat zien die een track bevatten van Iron Maiden.\nSELECT * FROM invoices WHERE EXISTS ( SELECT * FROM artists INNER JOIN invoice_items ON invoices.InvoiceId = invoice_items.InvoiceId INNER JOIN tracks ON invoice_items.TrackId = tracks.TrackId INNER JOIN albums ON tracks.AlbumId = albums.AlbumId where artists.Name = \u0026#39;Iron Maiden\u0026#39; AND albums.ArtistId = artists.ArtistId ); Schrijf een query die alle invoices laat zien die verkocht werden door Margaret Park. SELECT * FROM invoices WHERE EXISTS ( SELECT 1 FROM employees INNER JOIN customers ON customers.CustomerId = invoices.CustomerId WHERE employees.FirstName LIKE \u0026#39;Margaret\u0026#39; AND employees.EmployeeId = customers.SupportRepId ); Schrijf een query die alle genres laat zien waarvoor er geen track bestaat. SELECT * FROM genres WHERE NOT EXISTS ( SELECT 1 FROM tracks WHERE tracks.GenreId = genres.GenreId ); Schrijf een query die alle invoices laat zien waarvan de prijs groter is dan het gemiddelde van alle invoices. SELECT * FROM invoices WHERE Total \u0026gt; ( SELECT avg(Total) FROM invoices ); Schrijf een query die alle invoices laat zien waarin een Metallica track verkocht is, waarvan de prijs groter is dan het gemiddelde van alle invoices waarin een Metallica track verkocht is. "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/obj/week-3/",
	"title": "2. week 3",
	"tags": [],
	"description": "",
	"content": "Opdrachten Hoofdstuk 5 2.2.1 Zoek uit hoe std::pair, std::map, std::tuple en std::get() gebruik maken van templates op basis van de documentatie. Waarvoor gebruikt std::map default template argumenten? Waarom geven bepaalde varianten van insert() bij std::map een std::pair terug?\nZe maken gebruik van templates om objecten van alle types te kunnen opslaan zodat er niet voor alle mogelijke datastructuren een andere constructor moet gemaakt worden.\nstd::map() gebruikt default argumenten voor de compare en allocater variabelen.\nstd::map() returnt soms een std::pair omdat dit een boolean bevat die aangeeft of de insert gelukt is of niet.\n"
},
{
	"uri": "https://maarteng18.github.io/notes/archive/disch/ch-3/",
	"title": "3. Geheugens",
	"tags": [],
	"description": "",
	"content": "Table of contents RAM-geheugens ROM-geheugens Geheugenuitbreiding RAM-geheugens Situering RAM Indeling RAM SRAM (Statische RAM) Eigenschappen: Snel toegangelijk Veel oppervlakte Gebruiksgebied: Cachegeheugen DRAM (Dynamische RAM) Eigenschappen: Hoge densiteit Relatief trage uitlezing Gebruiksgebied: Hoofdgeheugen Massageheugen SRAM Opbouw van een SRAM-cel Het basis geheugenelement is een lus van invertoren. Deze lus moet onderbroken worden om te schrijven (8 transistors nodig). We kunnen deze onderbreking weglaten als de transistors die schrijven meer stroom leveren dan de transistores in de geheugencel. Dit geeft een stroompad tussen voeding en grond, wat zorgt voor een belangrijke opwarming. Gebruik ban transistors met minimale dimensies nMOS heeft een betere geleidbaarheid da pMOS Dubbel gebruik Schrijven Beide lijnen sturen 1 lijn trekt stroom Uitlezen SRAM-geheugenstructuur SRAM adresdecoder Om een woordlijn te selecteren, gaan we: Niet alle woordlijnen extern doorgeven Wel het nummer van de woordlijn Bv.: 64 woordlijnen Adres is een 6-bit getal 6 adreslijnen nodig De omzetting van het adres naar de overeenstemmende woordlijnen gebeurt in de adresdecoder, hoe meer bits het adres bevat: Hoe groter de decoder Hoe trager de decoder SRAM-organisatie In- en uitgangen:\nCS = Chip Select (actief laag) WE = Write Enable (actief laag) 10 adreslijnen 4 bi-directionele datalijnen SRAM-timing Vereenvoudigde read timing:\nVereenvoudigde write timing:\nBattery back-up RAM is per definite vluchtig\nZodra de spanning wegvalt, gaat de inhoud van het geheugen verloren. Batterij kan ervoor zorgen dat de inhoud toch niet verloren gaat. De batterij kan zelfs ingebouwd worden in de IC-behuizing. ROM-geheugens Opbouw van een DRAM-cel Geheugenelement = 1 tranistor (+ capiciteit) Lezen: laad bitlijn vooraf op tot vaste spanning, stuur woordlijn, meet bitlijn Schrijven: stuur bitlijn, stuur woordlijn Read-out is destructief Refresh cyclus nodig, want opslag verdwijnt op minder dan een ms. Een intern circuit leest het woord en schrijft het terug. Situering ROM Masker ROM met diodes Er worden overal diodes geplaatst Het masker bepaalt welke diodes verbonden worden Dit is veruit de meest eenvoudige wijze om een masker ROM te maken.\nAlle data lijnen zijn via een weerstand met de voeding verbonden. Uitgangen van de decoder zijn in rust verbonden met de voedingsspanning. Het zijn actief lage signalen, zoals aangegeven door het driehoekje aan de uitgang. Over de diodes staat geen spanning en er loopt ook geen stroom. Wanneer er een adres aangelegd wordt aan de ingang van de decoder: Zal de overeenkomstige woordlijn laag worden (0V). Als gevolg hiervan gaan de diodes die met deze woordlijn verbonden zijn geleiden, waarbij de stroom niet bepaald wordt door de diode maar door de weerstand die ermee in serie staat. Aan de uitgangen (D3…D0) hebben we dus typisch 0,7V of VCC, afhankelijk van het feit of er al dan niet een diode aanwezig is. Deze 0,7V ligt onder de drempelspanning van het hierop volgende circuit zodat ze als een digitale 0 herkend wordt. De diodes staan dus op de plaatsen waar er een 0 aanwezig moet zijn in het geheugen. Het is belangrijk op te merken dat er een DC stroom vloeit tussen de voedingsspanning en de uitgangen van de decoder, waardoor de decoder zwaar belast wordt. Een ROM geheugen dat op deze manier geïmplementeerd is, zal dus veel vermogen verbruiken.\nMasker ROM met transistors Een masker ROM kan ook met transistors worden uitgevoerd De decoder wordt hierdoor niet belast. We kunnen in de voorgaande schakeling de diodes vervangen door transistors. Hierdoor moet de decoder niet meer die belangrijke stroom leveren. De stroom van de decoder is beperkt tot de laadstroom van de gate capaciteiten van de transistors. Er blijft nog steeds een DC-stroom lopen, maar deze loopt van de voeding naar de grond via de transistors.\nMerk op dat de uitgang van de decoder in deze schakeling actief hoog is.\nMasker ROM met precharge De precharge zorgt ervoor dat er geen DC-stroom door de bitlijnen loopt. De bitlijnen worden telkens geprecharged vooraleer de decoder wordt uitgelezen. PROM PROM = Programmable ROM Het geheugen kan geprogrammeerd worden door bepaalde fuses/antifuses op te blazen. Er is geen specifiek masker nodig bij de productie. Programmeren gebeurt door hoge spanningspulsen aan te leggen (hogere spanning bij normale werking). EPROM FAMOS technologie Erasable Programmable ROM FAMOS = FLoating gate Avalanche injection MOS transistor UV-wisbaar Een FAMOS transistor is uitgevoerd met een dubbele gate.\nDe bovenste gate is verbonden met de woordlijn. De onderste gate is echter met niets verbonden en is dus zwevend. In normale omstandigheden is er geen lading aanwezig op de onderste gate. Wanneer er echter, door het aanleggen van een hogere voedingsspanning aan de gate, langdurig een zeer grote stroom tussen source en drain getrokken wordt, gaan er elektronen zijn die door botsingen een voldoende grote energie bekomen om in staat te zijn over het oxide heen te vliegen (lawine-effect). In dit geval wordt de zwevende gate opgeladen met elektronen.\nTijdens de normale werking van deze nMOS transistor in FAMOS technologie leggen we een positieve spanning aan aan de bovenste gate. Dit zorgt voor een positieve lading op de bovenste gate en een kanaal van elektronen onder de gates waardoor de transistor geleidt. Wanneer de zwevende gate echter is opgeladen met elektronen zal de positieve lading op de bovenste gate gecompenseerd worden door de elektronenlading op de zwevende gate en bekomen we geen elektronen meer in het kanaal tussen source en drain. De transistor zal dus niet geleiden.\nDe lading van de zwevende gate kan verdwijnen als de ladingsdragers voldoende energie krijgen. Dit kan m.b.v. UV-licht.\nEPROM Het programmeren van het geheugen gebeurt in een speciale EPROM-programmer. Het wissen gebeurt a.d.h.v. UV-licht.\nIn een EPROM geheugen is er een FAMOS transistor aanwezig op elke positie. Door het aanleggen van een hogere voedingsspanning kan er gekozen worden welke transistors niet mogen geleiden. Het hele geheugen kan gewist worden m.b.v. UV-licht. Het is niet mogelijk om enkel specifieke geheugenplaatsen te wissen.\nFLOTOX EEPROM technologie EEPROM = Electrically Erasable Programmable ROM FLOTOX = Floating gate Tunnel Oxide Er wordt gebruik gemaakt van een dun oxide. Op die manier is er geen UV-licht nodig om te wissen, het wissen gebeurt elektrisch (in-circuit programming). Een EEPROM maakt gebruik van het doortunneleffect om een zwevende gate op te laden. Er is een dun oxide voorzien boven de drain van de transistor. De elektronen gaan doortunnelen naar de zwevende gate wanneer er een voldoende hoge spanning wordt aangelegd aan de bovenste gate.\nEen belangrijk voordeel van het opladen van de zwevende gate door doortunnelen, is dat dit principe ook omkeerbaar is, zodat een EEPROM elektrisch kan gewist worden. Het wissen gebeurt door een spanning aan te leggen tussen drain en source zonder de bovenste gate op te laden. De elektronen tunnelen dan terug door het dunne oxide. Het gevolg hiervan is wel dat tijdens het gebruik van het geheugen de bovenste gate steeds moet verbonden zijn met de voedingsspanning om ervoor te zorgen dat de elektronen niet terug doortunnelen naar de drain. De woordlijntransistor en de programmeertransistor kunnen dus niet meer dezelfde zijn. Daarom hebben we voor een EEPROM geheugen een tweede transistor nodig per geheugenelement.\nFLASH geheugen Vergelijkbaar met EEPROM Veel sneller en compacter dan EEPROM, omdat het wissen en herprogrammeren in grote blokken gebeurt. Niet-vluchtig RAM Combinatie van SRAM (snel) EEPROM (traag) Onder normale werking: SRAM Een \u0026ldquo;store\u0026rdquo;-bevel slaat alles op in de EEPROM Een \u0026ldquo;recall\u0026rdquo;-bevel haalt alles uit de EEPROM Wanneer de voedingsspanning wegvalt, kan een \u0026ldquo;power failure\u0026rdquo; schakelingen dit selecteren en tijdig een \u0026ldquo;store\u0026rdquo;-bevel geven. Geheugenuitbreiding Het principe van geheugenuitbreiding is van toepassing op zowel ROM- als RAM-geheugens\nUitbreiding van de woordbreedte: Het aantal bereikbare adressen blijft gelijk Het aantal bits per adres wordt uitgebreid Uitbreiding van het adresbereik: Het aantal bits per adres blijven gelijk Het aantal bereikbare adressen worden uitgebreid Uitbreiding van de woordbreedte (voorbeeld) We vertrekken van twee ROM IC\u0026rsquo;s met een adres van 10 bits (dus een adresbereik van 210 adressen) en een woordbreedte van 4 bits. Beide IC\u0026rsquo;s krijgen hetzelfde adres. Beide IC\u0026rsquo;s produceren 4 bits van de data. In totaal zijn er 8 databits beschikbaar. Uitbreiding van het adresbereik (voorbeeld) We vertrekken van dezelfde 2 IC\u0026rsquo;s. Beide IC\u0026rsquo;s krijgen de 10 minst beduidende adreslijnen. De 11de adreslijn wordt gebruikt voor de \u0026ldquo;chip select\u0026rdquo;. De 4 data bits komen van 1 van de 2 chips. Geheugenmodules Per module staan een aantal IC\u0026rsquo;s georganiseerd volgens het principe van het uitbreiden van de woordbreedte. Indien de woordbreedte van de module kleiner is dan de breedte van de databus, moeten meerdere modules gelijktijdig gebruikt worden zodat de woordbreedte kan worden uitgebreid tot de breedte van een databus. Deze combinatie noemen we een geheugenbank. Meerdere geheugenbanken kunnen gecombineerd worden voor het uitbreiden van het adresbereik. Moderne geheugenmodules hebben een woordbreedte die overeenstemt met de breedt van de databus. Startende van geheugenblokken met een woordbreedte van 64 bits en een diepte van 128 woorden:\nTeken het schema van een geheugen met een woordbreedte van 256 bits en een diepte van 128 woorden. Teken het schema van een geheugen met een woordbreedte van 64 bits en een diepte van 256 woorden. Teken het schema van een geheugen met een woordbreedte van 256 bits en een diepte van 512 woorden. "
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-3/",
	"title": "3. Klasse A versterker",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/courses/databases/week-4/",
	"title": "3. week 4",
	"tags": [],
	"description": "",
	"content": "Vragen nog verbeteren.\nRDBMS Transacties Transaction Management Basics Er kan geen media recovery gebruikt worden omdat er bijvoorbeeld in een task een waarde veranderd wordt en deze daarna nog eens kan veranderen binnen dezelfde task. Als dit voorkomt en de data revocery valt toevallig tussen de 2 veranderingen dan zal de database op een fout moment gerecovered worden.\nEr kunnen problemen voorkomen zoals berekeningen doen met waarden die niet juist zijn omdat elke task nog de foute waarde ziet omdat de veranderingen van 1 task nog niet gecommit zijn.\nBij UNDO moeten er een aantal stappen van de een task ongedaan gemaakt worden omdat de task nog niet is afgelopen bij de failure. Bij REDO moeten de taken opnieuw worden uitgevoerd omdat deze nog niet zijn opgeslaan in de recovery.\nDe database zou beschermd moeten worden zodat er dan geen wijzigingen kunnen gebeuren of er moet terug gegaan kunnen worden naar een recovery state van voor de crash waardoor de mogelijke wijzigingen ongedaan worden gemaakt.\nDan zal degene die zijn aanvraag om het artikel in het winkelmandje te doen het eerste bij de database manager komt degene zijn die voorrang krijgt en daardoor het artikel zal kunnen kopen. Aan de andere persoon zal dan een melding komen dat het artikel niet meer in stock was.\nConcurrency Control Er zijn nog inserts mogelijk\nTransactie 1 zou kunnen lezen terwijl transactie nog lijnen wil toevoegen en zo gaan ze elkaar in een deadlock brengen.\nAtomicity, Isolation\nHoe meer locks er zijn hoe trager alles wordt want er moeten meer transacties op elkaar wachten.\n"
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-4/",
	"title": "4. Klasse B versterker",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/disch/ch-4/",
	"title": "4. Ontwerpprincipes voor synchrone logica",
	"tags": [],
	"description": "",
	"content": "Table of contents Voorbeeld ter introductie Ontwerpvoorbeeld: AES Voorbeeld ter introductie Kleren worden gewassen in 3 stappen:\n1 wasmand verwerken Het verwerken van 1 wasmand duurt 1 uur Throughput = 1 wasmand/uur Latency per wasmand = 1 uur 3 wasmanden verwerken Het verwerken van 3 wasmanden duurt 3 uren als we de wasmanden 1 voor 1 volledig verwerken Throughput = 1 wasmand/uur Latency per wasmand = 1 uur Verhogen van de throughput Parallellisatie Elke machine wordt 3x voorzien Het verwerken van 3 wasmanden duurt 1 uur Throughput = 3 wasmanden/uur Latency per wasmand = 1 uur Pipelining Throughput = 3 wasmanden/uur (na de opstartfase) Latency per wasmand = 1 uur Wat als het proces meerdere keren wordt doorlopen Stel dat een wasmand 3 keer na mekaar het hele proces moet doorlopen. Dan kunnen we geen pipelining gebruiken als elke machine maar 1 keer voorzien is. Loop unrolling Elke machine 3 keer voorzien + pipelining toepassen Ontwerpvoorbeeld: AES Animatie\nLoop architectuur AES: 1 klokcyclus per ronde (parallelle verwerking van 128 bits):\nThroughput = T Oppervlakte = A AES: 16 klokcycli per ronde (verwerking byte-per-byte):\nThroughput ≈ T/16 Oppervlakte \u0026gt; A/16 Loop unrolling Loop unrolling zonder pipelining: throughput = T, oppervlakte ≈ 10 * A\nLoop unrolling met pipelining: throughput ≈ 10 * T, oppervlakte ≈ 10 * A\n"
},
{
	"uri": "https://maarteng18.github.io/notes/archive/disch/ch-5/",
	"title": "5. Simulatie",
	"tags": [],
	"description": "",
	"content": "Table of contents Testbenches Evalutie van een hardware-ontwerp Testbenches Doelstelling van testbenches Het testen van VHDL code (of delen van code) zodat de juiste werking kan getest worden voordat de code geïmplementeerd wordt in een hardware component. Het definiëren van een omgeving die in eens testmachine kan gebruikt worden om een bestaande component te testen. Een elektronisch ontwerp maken op zich volstaat niet. Bij een goed ontwerp bestaat minstens 50 % van de ontwerptijd uit het uitdenken en uitwerken van testen die verzekeren dat het ontwerp functioneert zoals het moet. Deze testen dienen zowel te gebeuren tijdens de verschillende iteraties en verbeteringen van het ontwerp als na de uiteindelijke realisatie. Het is ook goed om eerst de verschillende deelblokken uitvoerig en volledig te testen en pas daarna (als alle deelblokken correct werken) het geheel te testen. Het vlug wat signalen aanleggen nadat de VHDL code klaar is en het vlug even kijken of de uitgangssignalen zijn zoals we denken dat ze moeten zijn, volstaat duidelijk niet en is de foutieve aanpak.\nVoordelen van testbenches In een testbench kan je systematisch alle te voorziene situaties implementeren, zodat je de zekerheid hebt dat de component onder alles omstandigheden zal werken. Bij complexe systemen kan je niet manueel alle mogelijkheden testen. Debuggen kan gebeuren zonder de component in werkelijkheid te moeten programmeren. Bij een goed ontwerp zullen we gelijktijdig met het ontwerp (of zelfs vooraf) ook de testen waaraan het ontwerp dient te voldoen schrijven. Deze testen worden ook in VHDL beschreven en elke keer dat we het ontwerp testen, zullen we dat doen aan de hand van dezelfde testbench.\nImplementatie Een nieuw bouwblok (van een hoger niveau) wordt gecreëerd. Deze bouwblok gebruikt de te testen blok (DUR of Device Under Test) als component: Ingangssignalen worden hieraan aangelegd Uitgangssignalen worden opgemeten De verschillen tussen wat verwacht wordt en wat bekomen wordt, worden gerapporteerd. Naar het scherm toe Naar een tekstfile Basisstructuur van een testbench De entity van de testbench bevat geen port. De architecture vangt aan met de declaratie van alle input en output signalen van de DUT en eventueel ook de declaratie van ee log-file om resultaten in weg te schrijven. De component die moet getest worden, wordt vervolgens gedeclareerd. entity testbench is end testbench; architecture test of tesbench is signal in0,in1,in2,in3: bit; signal output: bit; component te_testen port(in0, in1, in2, in3: in bit; output: out bit); end component; In de body van de architectuur (na begin instructie) staat vervolgens de instantiatie van de resten component. Daarna volgen processen die inputs aanleggen of outputs wegschrijven. begin dut: te_testen port map(in0, in1, in2, in3, output); process begin in0 \u0026lt;= \u0026#39;1\u0026#39;; in1 \u0026lt;= \u0026#39;0\u0026#39; after 1 ns; wait for 10 ns; in2 \u0026lt;= \u0026#39;0\u0026#39;; in3 \u0026lt;= \u0026#39;1\u0026#39; after 1 ns; wait for 10 ns; in0 \u0026lt;= \u0026#39;0\u0026#39;; in1 \u0026lt;= \u0026#39;1\u0026#39; after 1 ns; wait for 10 ns; in2 \u0026lt;= \u0026#39;1\u0026#39;; in3 \u0026lt;= \u0026#39;0\u0026#39; after 1 ns; wait for 10 ns; end process; Kloksignaal in een testbench De klok-periode kan als constant gedaclareerd worden CONSTANT clk_period = time := 10 ns; De klok kan gegenereerd worden door een speciaal proces. clk_process: process begin clk \u0026lt;= \u0026#39;0\u0026#39;; wait for clk_period/2; clk \u0026lt;= \u0026#39;1\u0026#39;; wait for clk_period/2; end process; Berichten in een testbench De assert instructie laat toe berichten mee te delen. De assert instructie wordt gevolgd door een booleaanse expressie. Als aan deze expressie niet voldaan is wordt een \u0026ldquo;assetion violation\u0026rdquo; gerapporteerd. (default) assert (out = (in1 and in2)); Je kan hetgeen gerapporteerd wordt aanpassen met een report keyword Na de report moet altijd een string volgen. assert (out = (in1 and in2)) report \u0026#34;De and-poort werkt niet\u0026#34;; De report kan ook los staan. report \u0026#34;Ik ben nu in deze lus\u0026#34;; De ernst van het bericht kan je aanpassen met het severity keyword. De ernst die hierop volgt moet van het type severity_level zijn. Je kan bepalen bij welke erns de simulator moet stoppen. assert (out = (in1 and in2)) report \u0026#34;Fout\u0026#34; severity ERROR; type severity_level is (note, warning, error, failure); Evalutie van een hardware-ontwerp Maximale klokfrequentie = 1/(vertraging van het kritisch pad) Bepaling van de maximale klokfrequentie door de tools: Leg een bepaalde klokfrequentie op. Check via de ontwerptools of de opgelegde frequentie kan gehaald worden. Indien niet: herhaal met een lagere klokfrequentie Indien wel: herhaal met een hogere klokfrequentie De maximale klokfrequentie is gelijk aan de hoogste klokfrequentie waarover de tools rapporteren dat ze gehaald kan warden. "
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-5/",
	"title": "5. voedingen",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-6/",
	"title": "6. GaN transistor toepassingen",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-7/",
	"title": "7. Thyristors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-8/",
	"title": "8. Berekening van elektronische circuits",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-9/",
	"title": "9. Niet-lineaire OpAMP schakelingen",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/christmas/christmas/",
	"title": "Christmas",
	"tags": [],
	"description": "",
	"content": "Taakverdeling Kerstmis Aanwezigen Karien \u0026amp; Geert: 2 Mieke \u0026amp; Gert: 6 Filip \u0026amp; Isabelle: 4 Tine \u0026amp; Tjeu: 3 Mark \u0026amp; Sandra: 5 Oma \u0026amp; Opa: 2 Totaal: 22 personen\nGourmetstellen 1x Sandra \u0026amp; Mark (6p.) 1x Sandra \u0026amp; Mark (klein) 1x Karien \u0026amp; Geert (6p.) Overige op de tennis aanwezig Voorbereidingen Karien \u0026amp; Geert Komkommer Kwarteleieren sla + tomaten Crème brûlée Voorbereidingen Mieke \u0026amp; Gert Vis 2x Pasta Wortelen Mayonaise \u0026amp; Ketchup Chocomousse Delhaize Tiramisu Slagroom Voorbereidingen Filip \u0026amp; Isabelle Aperitiefhapjes (chips, nootjes, grissini + spread) Ijsjes -\u0026gt; mini\u0026rsquo;s Advocaat Voorbereidingen Tine \u0026amp; Tjeu Paprika snijden voor pannetjes Voorbereidingen Mark \u0026amp; Sandra Vlees (9x deluxe, 9x gewoon) + Voor de kids in de AH Verlengkabels Aardappelsalade Stokbrood Champignonschijfjes + room Pepersaus + champignonsaus Cocktailsaus "
},
{
	"uri": "https://maarteng18.github.io/notes/scripts-commands/imagemagick/montage/",
	"title": "Montage",
	"tags": [],
	"description": "",
	"content": "Paste images underneath eachother With this command you can paste images underneath eachother into a montage.\nmontage [1-3].PNG -tile 1 -geometry 500x300+1+1 combo.png\n"
},
{
	"uri": "https://maarteng18.github.io/notes/scripts-commands/markdown/notices/",
	"title": "Notices",
	"tags": [],
	"description": "",
	"content": "Note {{% notice note %}} A notice disclaimer {{% /notice %}} renders as\nA notice disclaimer\n{{% notice todolist %}} A notice disclaimer {{% /notice %}} renders as\nA notice disclaimer\n{{% notice summary %}} A notice disclaimer {{% /notice %}} renders as\nA notice disclaimer\n{{% notice info %}} A notice disclaimer {{% /notice %}} renders as\nA notice disclaimer\n{{% notice tip %}} A notice disclaimer {{% /notice %}} renders as\nA notice disclaimer\n{{% notice warning %}} A notice disclaimer {{% /notice %}} renders as\nA notice disclaimer\n"
},
{
	"uri": "https://maarteng18.github.io/notes/courses/algoritmen-en-datastructuren/week-1/",
	"title": "Week 1",
	"tags": [],
	"description": "",
	"content": "Table of contents Initial Exercises on Chapters 1, 2 and 3 Chapter 1: Why Data Structures Matter Chapter 2: Why Algorithms Matter Chapter 3: Big Oh Notation Initial Exercises on Chapters 1, 2 and 3 You retrieve a list of all items that have been sold during the last trimester from a web shop’s database. Unfortunately, you end up with a simple array: if an item was sold three times, it occurs three times in that array. You want to count how many times one particular item has been sold. How many steps does it take to find this when the array is unordered? And when ordered? Answer in terms of N, both for the best-case and worst-case scenario.\nAnswer unordered:\nBest-case: N Worst-case: N Answer ordered:\nBest-case: 2 Worst-case: N Given the following array: [2, 4, 6, 8, 10, 12, 13]?\nHow many steps would a linear search for a number take? How many steps would a binary search for a number take? Answer in therms of N, both for the best-case and worst-case scenario.\nHow would you define an average-case scenario? How many steps would both take in such a scenario? According to you, which scenario is most valuable to analyze: the best-case, worst-case or average-case scenario?\nAnswer 1:\nBest-case: 1 Worst-case: N Answer 2:\nBest-case: 1 Worst-case: 3 I would define the average-case scenario as the average between the best-case and worst-case scenario. So question one would have an average-case-scenario of (1+N)/2 = 4.5 and question two would have an average-case-scenario of (1+3)/2 = 2. The best scenario to analyze would be the worst case scenario because this is the only way to be sure the algorithm is fully optimized.\nImplement the algorithms from exercise 1.2.2: write two functions that search a certain number in a given array of numbers and return the index of that number when found (-1 if not found). One function uses linear search, the other function uses binary search.\nExtend or adapt your code to verify your answers from exercise 1.2.2. Add a counter to each algorithm that starts at 0 and increments each time you execute a step. Think about what qualifies as a ‘step’.\nFinally, compare the execution time of both algorithms. To this end, you can use the C++ std::chrono library (or similar approaches in Java, Python . . . ). Try measuring the execution time at the point where you call your functions, and also inside your functions. Experiment with various sizes of arrays, from small to very big. Can you explain the results?\nNote: in the next chapter, we will retake this exercise and you will be asked to extend your solution, so make sure that you have a working implementation.\nAnswer linear search:\n#include \u0026lt;iostream\u0026gt; void linearSearch(int array[], int number); int main() { int arr[5]{}; std::cout \u0026lt;\u0026lt; \u0026#34;Enter 5 elements of the array.\\n\u0026#34;; for (int i = 0; i \u0026lt; 5; i++) { std::cin \u0026gt;\u0026gt; arr[i]; } std::cout \u0026lt;\u0026lt; \u0026#34;Enter an element to search.\\n\u0026#34;; int num{}; std::cin \u0026gt;\u0026gt; num; linearSearch(arr, num); return 0; } void linearSearch(int array[], int number) { int temp{ -1 }; for (int i = 0; i \u0026lt; 5; i++) { if (array[i] == number) { std::cout \u0026lt;\u0026lt; \u0026#34;Element found at index: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; temp = 0; break; } } if (temp == -1) { std::cout \u0026lt;\u0026lt; \u0026#34;No Element Found\u0026#34; \u0026lt;\u0026lt; std::endl; } } Answer binary search:\n#include \u0026lt;iostream\u0026gt; int binarySearch(int array[], int left, int right, int number); int main() { int arr[5]{}; std::cout \u0026lt;\u0026lt; \u0026#34;Enter 5 elements of the array.\\n\u0026#34;; for (int i = 0; i \u0026lt; 5; i++) { std::cin \u0026gt;\u0026gt; arr[i]; } std::cout \u0026lt;\u0026lt; \u0026#34;Enter an element to search.\\n\u0026#34;; int num{}; std::cin \u0026gt;\u0026gt; num; int result = binarySearch(arr, 0, 4, num); (result == -1) ? std::cout \u0026lt;\u0026lt; \u0026#34;Element is not present in array\u0026#34; \u0026lt;\u0026lt; std::endl : std::cout \u0026lt;\u0026lt; \u0026#34;Element is present at index \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; return 0; } int binarySearch(int array[], int left, int right, int number) { if (right \u0026gt;= left) { int mid = left + (right - left) / 2; if (array[mid] == number) return mid; if (array[mid] \u0026gt; number) return binarySearch(array, left, mid - 1, number); return binarySearch(array, mid + 1, right, number); } return -1; } A binary tree is a tree in which each node has zero, one or two children (see figure). How many steps would a search for a number take in such a tree? Answer in terms of N.\nAnswer:\nIn this three the worst-case would be 3 steps.\nWhy Data Structures Matter Exercises For an array containing 100 elements, provide the number of steps the following operations would take:\nReading Searching for a value not contained within the array Insertion at the beginning of the array Insertion at the end of the array Deletion at the beginning of the array Deletion at the end of the array Answers:\n1 step 100 steps 101 steps 1 step 100 steps 1 step For an array-based set containing 100 elements, provide the number of steps the following operations would take:\nReading Searching for a value not contained within the set Insertion of a new value at the beginning of the set Insertion of a new value at the end of the set Deletion at the beginning of the set Deletion at the end of the set Answers:\n1 step 100 steps 201 steps 101 step 100 steps 1 step Normally the search operation in an array looks for the first instance of a given value. But sometimes we may want to look for every instance of a given value. For example, say we want to count how many times the value \u0026ldquo;apple\u0026rdquo; is found inside an array. How many steps would it take to find all the \u0026ldquo;apples\u0026rdquo;? Give your answer in terms of N.\nAnswer:\nN steps\nWhy Algorithms Matter Exercises on Why Algorithms Matter How many steps would it take to perform a linear search for the number 8 in the ordered array, [2, 4, 6, 8, 10, 12, 13]?\nAnswer:\n4 steps\nHow many steps would it take to perform a binary search for the number 8 in the ordered array, [2, 4, 6, 8, 10, 12, 13]?\nAnswer:\n1 step\nWhat is the maximum number of steps it would take to perform a binary search on an array of size 100,000?\nAnswer:\n16 steps\nBig Oh Notation Exercises on Big Oh Notation Use Big O Notation to describe the time complexity of the following function that determines whether a given year is a leap year:\nfunction isLeapYear(year) { return (year % 100 === 0) ? (year % 400 === 0) : (year % 4 === 0); } Answer:\nO(1)\nUse Big O Notation to describe the time complexity of the following function that sums up all the numbers from a given array:\nfunction arraySum(array) { let sum = 0; for(let i = 0; i \u0026lt; array.length; i++){ sum += array[i]; } return sum; } Answer:\nO(N)\nThe following function is based on the age-old analogy used to describe the power of compounding interest:\nImagine you have a chessboard and put a single grain of rice on one square. On the second square, you put 2 grains of rice, since that is double the amount of rice on the previous square. On the third square, you put 4 grains. On the fourth square, you put 8 grains, and on the fifth square, you put 16 grains, and so on.\nThe following function calculates which square you\u0026rsquo;ll need to place a certain number of rice grains. For example, for 16 grains, the function will return 5 since you will place the 16 grains on the fifth square.\nfunction chessboardSpace(numberOfGrains) { let chessboardSpaces = 1; let placedGrains = 1; while (placedGrains \u0026lt; numberOfGrains) { placedGrains *= 2; chessboardSpaces += 1; } return chessboardSpaces } Answer:\nO(log N)\nThe following function accepts an array of strings and returns a new array that only contains the string that start with the character \u0026ldquo;a\u0026rdquo;. Use Big O Notation to describe the time complexity of the function:\nfunction selectAString(array) { let newArray = []; for(let i = 0; i \u0026lt; array.length; i++){ if (array[i].startsWith(\u0026#34;a\u0026#34;)) { newArray.push(array[i]); } } return newArray; } Answer:\nO(N)\nThe following function calculates the median from an ordered array. Describe its time complexity in therms of Big O Notation:\nfunction media(array) { const middle = Math.floor(array.length / 2); // If array has even amount of numbers: if (array.length % 2 === 0) { return (array[middle - 1] + array[middle]) / 2; } else { // If array has odd amount of numbers: return array[middle]; } } Answer:\nO(1)\n"
},
{
	"uri": "https://maarteng18.github.io/notes/courses/cct/week-1/",
	"title": "Week 1",
	"tags": [],
	"description": "",
	"content": "Deel 1: Intro Paper \u0026lsquo;Future Generation Computer Systems\u0026rsquo; lezen (misschien een examenvraag uit deze paper).\nDeel 2: Isolatie Zeer korte uitleg van de theorie, ppt nog studeren.\n"
},
{
	"uri": "https://maarteng18.github.io/notes/courses/algoritmen-en-datastructuren/week-2/",
	"title": "Week 2",
	"tags": [],
	"description": "",
	"content": "Table of contents Exercises on Chapters 1, 2 and 3 Initial Exercises on Chapters 4, 5 and 6 Exercises on Chapters 1, 2 and 3 According to the documentation, which kind of functions do the C++ Standard Library and Java provide to search a value in an array? What kind of algorithms ara available in the Boost C++ Libraries? Use these libraries (unless instructed otherwise) to make your work easier.\nAnswer:\nYou want to use a dynamically allocated array to store items: you decide to start with an array of size one and each time the array is full, you resize the array so it doubles in size. This function returns the number of times you have to resize the array before it is able to hold a certain number of items: for x == 16, it returns 4, since resizing 4 times leads to an array of size 16.\nint numberOfResizes(int x) { int n{0}, size {1}; while (size \u0026lt; x) { size *= 2; n++; } return n; } Use the Big O notation to describe its time complexity. Can you improve the efficiency of this algorithm? If yes, how?\nAnswer:\nN is x O(log n) Kan makkelijker door gewoon te berekenen\nThis simple function calculates the median from an ordered array. Describe its time complexity in terms of the Big O notation. What is the pitfall here, compared to similar exercises on arrays?\nfloat median(float array[], int size) { const int middle{ (int) floor(size / 2) }; if (size % 2 == 0) // array has even amount of numbers return (array[middle - 1] + array[middle]) / 2; else // array has odd amount of numbers return array[middle]; } Answer:\nN is irrelevant wat constant O(1) want vaste tijd\nWrite a short function that, given an array of N strings, returns how many of those strings are a palindrome. Use this isPalindrome() as a helper function.\nbool isPalindrome(string s) { bool result{true}; for (int i{0}; i \u0026lt; s.length(); ++i){ if (s[i] != s[s.length() - i - 1]) { result = false; } } return result; } Describe the time complexity of the helper function, as well as the time complexity of your complete solution in terms of the Big O notation. What are the possible pitfalls here?\nCan you improve (the time complexity of) the helper function? Another approach to check if a string is a palindrome: first reverse the string, then compare the reversed string to the original string. Is this approach as efficient as the previous algorithm? Are there other factors to consider here?\nAnswer:\nM = lentge s =\u0026gt; O(M)\nN = # strings in array M = lengte langste string =\u0026gt; O(M*N)\nWe often search within strings. Have a look at a few examples of algorithms in this context. First, explore how the Knuth–Morris–Pratt algorithm searches for occurrences of a word within a string and how it improves the time complexity compared to a naive approach of matching characters.\nNext, explore how you can find the longest repeated substring in a given string. For example, the longest repeated substring in “bananas” is “ana”. What is a suffix array and how can you use it in this context?\nAnswer:\nNiet echt kennen maar als de code er is, kunnen analyseren hoe snel het is en hoe het werkt.\nExplore the Boyer–Moore and Boyer–Moore–Horspool string-searching algorithms, their time complexity and how they compare to Knuth–Morris–Pratt.\nAnswer:\nWhile you have to be able to reproduce algorithms such as binary search, we do not expect you to memorize these string-searching algorithms. It is important, however, that you are able to comprehend, analyze, compare, adapt . . . such algorithms. Always read the “What You Should Know After this Lesson” section carefully to find out what we expect (if we expected you to be able to reproduce the Knuth–Morris–Pratt algorithm, it would have been mentioned by name) and when in doubt, ask about it in class\nExtra oefeningen achteraan boek\nInitial Exercises on Chapters 4, 5 and 6 Write three functions that sort an array of numbers: a bubble sort function, selection sort function and insertion sort function. Similar to exercise 1.2.3, add a counter to each algorithm that starts at 0 and increments each time you execute a step. Think about what qualifies as a ‘step’ and be consistent across functions, so you can compare the algorithms against each other.\nAdd a testing function that runs your algorithms for randomly generated arrays of size 100, 200, 300 . . . Each array should have random values between 0 and 99. In C++, you can use std::uniform_int_distribution to generate random numbers (or use a similar approach in Java, Python . . . ).\nFor each array size, generate 2000 arrays (one at a time) and run the three algorithms with each array. Average the number of steps executed for each algorithm separately and output your results in a tabular format, as shown below (XXXX indicates where your results need to be).\nAfterwards, copy the data into a spreadsheet (e.g. Google Sheets) and plot one curve for each algorithm, comparing the number of values in the array along the x-axis against the number of steps along the y-axis. Do the curves match the time complexity of each algorithm?\nSIZE ALG 1 ALG 2 ALG 3 100 XXXX XXXX XXXX 200 XXXX XXXX XXXX 300 XXXX XXXX XXXX 400 XXXX XXXX XXXX 500 XXXX XXXX XXXX 600 XXXX XXXX XXXX 700 XXXX XXXX XXXX 800 XXXX XXXX XXXX 900 XXXX XXXX XXXX \u0026hellip; XXXX XXXX XXXX Answer:\nAdd a few very simple sorting algorithms to exercise 2.3.1: cocktail shaker sort and Gnome sort. There are many more simple sorting algorithms you can explore (and we will look into more complex ones in later chapters)!\nAnswer:\n"
},
{
	"uri": "https://maarteng18.github.io/notes/courses/algoritmen-en-datastructuren/week-3/",
	"title": "Week 3",
	"tags": [],
	"description": "",
	"content": "Table of contents Exercises on Chapters 4, 5 and 6 Initial Exercises on Chapters 7, 8 and 9 Exercises on Chapters 4, 5 and 6 Your friend is solving a programming exercise: he has to write a simple program that looks for the largest and smallest number in an array. He already wrote the following helper function, but its time complexity is O(N2), so he clearly needs your help! Start by explaining why the time complexity of his algorithm is O(N2).\nNext, write a more efficient solution to find both the largest and smallest number, and explain why your solution is more efficient. What is the overall time complexity of your solution? What are the best-, average-, and worst-case scenarios?\nint max(int array[], int size) { for (int i{0}; i \u0026lt; size; ++i) { bool isMax{true}; for (int j{0}; j \u0026lt; size; ++j) { if (array[j] \u0026gt; array[i]) { isMax = false; } } if (isMax) { return array[i]; } } } Solve this without using the corresponding algorithms of the C++ Standard Library, but look them up afterwards. What is their time complexity?\nAnswer:\nAre bubble, selection and insertion sort stable or unstable sorting algorithms? Are they in-place or out-of-place? Are they online? Are they adaptive?\nIf you modify your insertion sort from exercise 2.3.1 to sort an array of strings in alphabetical order, is its time complexity affected? Why (not)? Could you improve insertion sort by combining it with binary search?\nAnswer:\nHow does this sorting algorithm work? Hint: the numbers in the array range between 0 and range. Analyze the time complexity of the algorithm and make sure to explain your analysis step by step.\nvoid sort(int array[], int size, int range) { int sorted[size], count[range]; for (int i{0}; i \u0026lt; range; ++i) count[i] = 0; for (int i{0}; i \u0026lt; size; ++i) ++count[array[i]]; for (int i{1}; i \u0026lt; range; ++i) count[i] = count[i] + count[i - 1]; for (int i{0}; i \u0026lt; size; ++i) sorted[--count[array[i]]] = array[i]; for (int i{0}; i \u0026lt; size; ++i) array[i] = sorted[i]; } What are its benefits and limitations? Can you modify the algorithm so it also works with negative numbers?\nAnswer:\nHow does radix sort work? Add your own implementation of this algorithm to exercise 2.3.1 (note that there are various ways to implement radix sort).\nHow does radix sort compare to insertion sort? What is its time complexity? Why is it called non-comparative sorting algorithm? Is it stable or unstable? In-place or out-of-place?\nWhen would you use radix sort? Can you use it to sort an array of strings in alphabetical order? How?\nAnswer:\nCan you deduce from the C++ documentation if std::sort uses one of the algorithms from this lesson? Is it a comparative sorting algorithm? Stable? What about sorting arrays in Java or Boost?\nAnswer:\nIn exercise 2.3.2, you analyzed the time complexity of a few additional sorting algorithms by testing them on randomly generated arrays. Now, describe their time complexity by analyzing the algorithms step by step.\nAnswer:\nInitial Exercises on Chapters 7, 8 and 9 1 Consult the documentation of the C++ Standard Library: how do the data structures std::unordered_map and std::unordered_set differ? What about the time complexity of their operations?\nWhat can you learn from the Java documentation about the load factor and capacity of a Hashtable, and their effects on efficiency? What is the purpose of the HashMap and HashSet classes in Java? For which purposes can you use multi-index containers, such as bimap in the Boost C++ Libraries?\nAnswer:\nWhat is the time complexity of finding the ‘smallest’ and ‘largest’ value in a hash table? Why? What would you do when you have inserted so many keys into your hash table that collisions occur every time?\nTry to come up with a hash function for strings by yourself. Afterwards, look up solutions that are used in practice and why these are effective at hashing strings. Would a cryptographic hash function like SHA-3 be suitable?\nAnswer:\n"
},
{
	"uri": "https://maarteng18.github.io/notes/courses/algoritmen-en-datastructuren/week-4/",
	"title": "Week 4",
	"tags": [],
	"description": "",
	"content": "Table of contents Exercises on Chapter 7 Exercises on Chapter 8 Exercises on Chapter 9 Exercises on Chapter 7 Extra oefeningen achteraan boek\nExercises on Chapter 8 Given an array with votes, which are represented by a number, for example {2, 4, 1, 2, 2, 5, 2, 3, 1, 2, 2}. Write a function that returns the majority vote (a vote that appears more than N/2 times; 2 is a majority vote in the example), if present. Create a solution with a hash table that stores the number of times that each vote occurs (e.g. std::unordered_map\u0026lt;int, int\u0026gt;).\nWhat is the time complexity of your solution? Next, compare this to the Boyer–Moore majority vote algorithm.\nAnswer:\nIn exercise 2.1.4, you had to look for palindromes. Now, write a function that, given a string, returns the longest palindrome that you can create with (a subset of) the characters of that string. For example, given the string “ABBDABCC”, the longest palindrome is “BACBCAB” (or “BACDCAB”, or . . . ; it suffices to return just one solution).\nHint: start by creating a hash table that stores the number of times that each character occurs in the given string and use this information to create the palindrome. Use a class such as std::string to easily append, reverse . . .\nAnswer:\nDetermine whether two given strings are isomorphic: s1 and s2 are isomorphic if all occurrences of each character in s1 can be replaced with another character to get s2 and the other way around. For example, “ADAG” and “XDXY” are isomorphic, as we can map ‘A’ - ‘X’, ‘G’ - ’Y’ and ‘D’ - ‘D’.\nA common mistake is to overlook certain cases, so make sure to test your code with various examples: “AADG” and “XDXY” are not isomorphic, but neither are “ADAD” and “XDXY” or “ADAG” and “XDXX”.\nAnswer:\nAnother method of collision resolution in hash tables is open addressing. Examine linear probing, quadratic probing and double hashing in detail, as well as their effect on search and insertion.\nGiven as input the numbers 42, 39, 57, 3, 18, 5, 67, 13, 83, 26, a hash table with a fixed size of 13, and the hash function H(x) = x mod 13. Write down the resulting hash table (similar to the drawings in the book, e.g. on pages 119-120) for separate chaining, linear probing, and quadratic probing. As an extra, you can also do it for double hashing.\nAnswer:\nImplement a hash table that uses linear probing. Support search and insertion. As an extra, you can implement deletion (e.g. with a lazy deletion strategy) and resizing (e.g. if the load factor exceeds a certain threshold, double the size of the data structure).\nAnswer:\nExercises on Chapter 9 Consult the documentation: in the C++ Standard Library, how do the data structures std::queue and std::deque differ? What about equivalents in Java?\nAnswer:\nThe book describes an approach to check whether code contains brace-related syntax errors. Write a program that implements this approach, using std::unordered_map to relate opening to closing braces (e.g. ‘(’ as key, ‘)’ as value) and std::stack to store characters\nAnswer:\n"
},
{
	"uri": "https://maarteng18.github.io/notes/courses/algoritmen-en-datastructuren/week-5/",
	"title": "Week 5",
	"tags": [],
	"description": "",
	"content": "Table of contents Exercises on Chapters 10, 11 and 12 Initial Exercises on Chapters 13 and 14 Exercises on Chapters 10, 11 and 12 Write a very simple recursive function power(x, n) that calculates xn. Next, write a second version of that function, using these rules:\nFor example, x6 = (x3)2 and x11 = x ∗ (x5)2. Is the second version of the function more efficient? What is the time complexity of both versions?\nAnswer:\nIn exercise 1.2.3, you presumably implemented binary search in an iterative manner, in exercise 2.1.4, an iterative function was used to determine whether a string is a palindrome, and in exercise 2.3.1, you implemented an iterative bubble, selection and insertion sort. Is it possible to implement them recursively? Which implementation do you think is more efficient?\nAnswer:\nThe Tower of Hanoi is a famous mathematical puzzle. Look up the problem and analyze how the recursive solution works.\nAnswer:\nWrite two recursive functions that return the nth number in the Fibonacci sequence: one without and one with memoization. Add a static counter to the functions: increase and print its value each time the function is called.\nTest both functions for a variety of values for n. What issues do you encounter when passing a large n? Can you improve your code in that respect? Can you find solutions for arithmetic overflow in the C++ Boost libraries?\nAnswer:\nWhat are tail recursion and tail call optimization? How can you write a function to calculate the factorial using tail recursion? Explain how it works by comparing a solution with and without tail recursion. What are the advantages and disadvantages?\nAnswer:\nGiven two strings, find the length of the longest subsequence found in both of them. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous: ‘abc’, ‘adg’, ‘bdf’ and ‘aceg’ are all subsequences of ‘abcdefg’. Write two recursive functions that return the length of the longest common subsequence: one without and one with memoization.\nAnswer:\nWrite a program that solves a Sudoku through backtracking. Find a blank cell in the grid, try to insert each value from 1 to 9, test if it is valid, and call the solver recursively. If the recursive call fails to find a solution, try other values in a previously blank cell. Can you intuitively deduce its time complexity based on the high-level steps?\nAnswer:\nInitial Exercises on Chapters 13 and 14 With quicksort, you need to select a certain element as your pivot. In the book, they use the last element. What other options are there, and what are their advantages or disadvantages?\nAnswer:\nConsult the documentation of the C++ Standard Library: are there implementations of a single and doubly linked list available? What about in the Boost C++ Libraries (look under ‘intrusive containers’)? What are their advantages and disadvantages compared to the std::vector class?\nAnswer:\n"
},
{
	"uri": "https://maarteng18.github.io/notes/courses/algoritmen-en-datastructuren/week-6/",
	"title": "Week 6",
	"tags": [],
	"description": "",
	"content": "Table of contents Exercises on Chapter 13 Exercises on Chapter 14 Initial Exercises on Chapter 15 Exercises on Chapter 13 Given an unsorted array of integers, for example {1, 5, 2, 2, 2, 5, 5, 4}. Print all the pairs of integers with a given difference d. With d == 3, the example array would give the following output: (2, 5) and (1, 4).\nA naive solution considers every possible pair in the array, with a time complexity of O(N²). Try to find a more efficient solution (there are multiple approaches, using algorithms and data structures from previous chapters).\nTo avoid duplicates in the output, you can first sort the array and skip adjacent duplicates in the array. Implementing a sorting algorithm is unnecessary: the C++ Standard Library, for instance, provides sorting functions.\nWhat is the time complexity of your solution?\nAnswer:\n#include \u0026lt;unordered_map\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; // The function assumes that the array is sorted bool findPair(int arr[], int size, int n) { std::unordered_map\u0026lt;int, int\u0026gt; mpp; for (int i = 0; i \u0026lt; size; i++) { mpp[arr[i]]++; // Check if any element whose frequency // is greater than 1 exist or not for n == 0 if (n == 0 \u0026amp;\u0026amp; mpp[arr[i]] \u0026gt; 1) return true; } // Check if difference is zero and // we are unable to find any duplicate or // element whose frequency is greater than 1 // then no such pair found. if (n == 0) return false; for (int i = 0; i \u0026lt; size; i++) { if (mpp.find(n + arr[i]) != mpp.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Pair Found: (\u0026#34; \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; n + arr[i] \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; return true; } } std::cout \u0026lt;\u0026lt; \u0026#34;No Pair found\u0026#34;; return false; } // Driver program to test above function int main() { int arr[] = { 8, 1, 9, 2, 100 }; int size = sizeof(arr) / sizeof(arr[0]); int n = 7; std::sort(arr, arr + size); findPair(arr, size, n); return 0; } Like quicksort, merge sort uses a divide-and-conquer strategy (this pseudocode is still missing important steps that you need to determine yourself):\nmergeSort(array, l, r)\rfind middle point m to divide array into two halves\rcall mergeSort for first half: mergeSort(array, l, m)\rcall mergeSort for second half: mergeSort(array, m + 1, r)\rmerge two halves sorted in step 2 and 3 with helper function Implement merge sort for a given array of numbers. Use the random array generator from exercise 2.3.1 to produce data to test your implementation.\nWhat is the time complexity of your solution?\nAnswer:\n// C++ program for Merge Sort #include \u0026lt;iostream\u0026gt; using namespace std; // Merges two subarrays of array[]. // First subarray is arr[begin..mid] // Second subarray is arr[mid+1..end] void merge(int array[], int const left, int const mid, int const right) { auto const subArrayOne = mid - left + 1; auto const subArrayTwo = right - mid; // Create temp arrays auto* leftArray = new int[subArrayOne], * rightArray = new int[subArrayTwo]; // Copy data to temp arrays leftArray[] and rightArray[] for (auto i = 0; i \u0026lt; subArrayOne; i++) leftArray[i] = array[left + i]; for (auto j = 0; j \u0026lt; subArrayTwo; j++) rightArray[j] = array[mid + 1 + j]; auto indexOfSubArrayOne = 0, // Initial index of first sub-array indexOfSubArrayTwo = 0; // Initial index of second sub-array int indexOfMergedArray = left; // Initial index of merged array // Merge the temp arrays back into array[left..right] while (indexOfSubArrayOne \u0026lt; subArrayOne \u0026amp;\u0026amp; indexOfSubArrayTwo \u0026lt; subArrayTwo) { if (leftArray[indexOfSubArrayOne] \u0026lt;= rightArray[indexOfSubArrayTwo]) { array[indexOfMergedArray] = leftArray[indexOfSubArrayOne]; indexOfSubArrayOne++; } else { array[indexOfMergedArray] = rightArray[indexOfSubArrayTwo]; indexOfSubArrayTwo++; } indexOfMergedArray++; } // Copy the remaining elements of // left[], if there are any while (indexOfSubArrayOne \u0026lt; subArrayOne) { array[indexOfMergedArray] = leftArray[indexOfSubArrayOne]; indexOfSubArrayOne++; indexOfMergedArray++; } // Copy the remaining elements of // right[], if there are any while (indexOfSubArrayTwo \u0026lt; subArrayTwo) { array[indexOfMergedArray] = rightArray[indexOfSubArrayTwo]; indexOfSubArrayTwo++; indexOfMergedArray++; } delete[] leftArray; delete[] rightArray; } // begin is for left index and end is // right index of the sub-array // of arr to be sorted */ void mergeSort(int array[], int const begin, int const end) { if (begin \u0026gt;= end) return; // Returns recursively auto mid = begin + (end - begin) / 2; mergeSort(array, begin, mid); mergeSort(array, mid + 1, end); merge(array, begin, mid, end); } // UTILITY FUNCTIONS // Function to print an array void printArray(int A[], int size) { for (auto i = 0; i \u0026lt; size; i++) cout \u0026lt;\u0026lt; A[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } // Driver code int main() { int arr[] = { 12, 11, 13, 5, 6, 7 }; auto arr_size = sizeof(arr) / sizeof(arr[0]); cout \u0026lt;\u0026lt; \u0026#34;Given array is \\n\u0026#34;; printArray(arr, arr_size); mergeSort(arr, 0, arr_size - 1); cout \u0026lt;\u0026lt; \u0026#34;\\nSorted array is \\n\u0026#34;; printArray(arr, arr_size); return 0; } Write a second version of your merge sort, where you use multiple threads to sort parts of the array. Is a quicksort with multiple threads also possible?\nAnswer:\nIn the Java documentation, you find that various algorithms are used to sort arrays. Explore two algorithms in particular: dual-pivot quicksort and timsort. How does a multi-pivot quicksort work and what are the advantages? Why is timsort called a hybrid sorting algorithm, how does it work, and why is it considered to be efficient?\nAnswer:\nExercises on Chapter 14 An application of node-based data structures is the implementation of treebased structures, in which nodes are linked hierarchically. A binary tree is a tree in which each node has zero, one, or two children (see figure).\nImplement a binary tree, preferably in C++, with recursive functions that:\ncalculate the amount of nodes in a tree; calculate the amount of levels in a tree; print each node\u0026rsquo;s value in reverse level order. With reverse level order traversal, you first visit the last level of a tree, then the second-to-last level, and so on. For each level, you visit the nodes from left to right. (Questions like this are common during job interviews.)\nIf you find such trees too difficult, first read the next chapter of the book.\nAnswer:\nInitial Exercises on Chapter 15 In the book, they state that the time complexity of deleting from a binary search tree is typically O(logN), because deletion requires a search plus a few extra steps. Analyze the code of the delete() function to verify this.\nAnswer:\nExtend exercise 6.2.1 with a recursive function that, given a binary tree and a number, returns whether the tree has a root-to-leaf path (a sequence of nodes starting with the root, going down to a leaf) for which the sum of all values on that path equals the given number.\nAnswer:\n"
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-10/",
	"title": "10. OTA schakelingen",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]