[
{
	"uri": "https://maarteng18.github.io/notes/courses/",
	"title": "Current Courses",
	"tags": [],
	"description": "",
	"content": "Current courses Databases Algoritmen en datastructuren Regeltechniek Cloud computing \u0026amp; toepassingen Objectgeoriënteerd programmeren "
},
{
	"uri": "https://maarteng18.github.io/notes/",
	"title": "Maarten&#39;s notes",
	"tags": [],
	"description": "",
	"content": "Maarten\u0026rsquo;s notes Current courses Analoge Elektronische Schakelingen Digitale Elektronische Schakelingen Android App Development Besturingssystemen en C Software Engineering Skills Good to know I\u0026rsquo;m currently making a portfolio, more coming soon\nSome usefull commands ImageMagick "
},
{
	"uri": "https://maarteng18.github.io/notes/scripts-commands/",
	"title": "Scripts &amp; commands",
	"tags": [],
	"description": "",
	"content": "Subjects ImageMagick Markdown "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/algoritmen-en-datasctructuren/",
	"title": "Algoritmen en datasctructuren",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/",
	"title": "Analoge Elektronische Schakelingen",
	"tags": [],
	"description": "",
	"content": "Chapters Herhaling MOSFET en BJT "
},
{
	"uri": "https://maarteng18.github.io/notes/archive/",
	"title": "Archive",
	"tags": [],
	"description": "",
	"content": "2nd Bachelor of Science Analoge Elektronische Schakelingen Digitale Elektronische Schakelingen Android App Development Besturingssystemen en C Software Engineering Skills "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/cct/",
	"title": "Cloud Computing &amp; toepassingen",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/courses/databases/",
	"title": "Databases",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/disch/",
	"title": "Digitale Elektronische Schakelingen",
	"tags": [],
	"description": "",
	"content": "Chapters Inleiding Programmeerbare logica Geheugens Ontwerpprincipes voor synchrone logica Simulatie Zelfstudie VHDL Zelfstudie FSM "
},
{
	"uri": "https://maarteng18.github.io/notes/scripts-commands/imagemagick/",
	"title": "Image Magick",
	"tags": [],
	"description": "",
	"content": "Subjects Montage "
},
{
	"uri": "https://maarteng18.github.io/notes/scripts-commands/markdown/",
	"title": "Markdown",
	"tags": [],
	"description": "",
	"content": "Subjects Notices "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/obj/",
	"title": "Objectgeoriënteerd programmeren",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/courses/regeltechniek/",
	"title": "Regeltechniek",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-1/",
	"title": "1. Herhaling MOSFET en BJT",
	"tags": [],
	"description": "",
	"content": "MOSFET Werking MOS transistor De MOS transistor bestaat uit: een gate gemaakt uit polykristallijn Si boven op een heel dun oxide dat op het Si neergelegd is. een source en een drain die geïmplementeerd zijn a.d.h.v. een pn-junctie gescheiden van de bulk. Wanneer er een spanning aangelegd wordt aan de gate: Eerst zorgen dat ladingsdragers van de bulk, die van een tegengesteld type zijn dan de gewenste ladingsdragers, voldoende ver van onder de gate verdwijnen. BJT "
},
{
	"uri": "https://maarteng18.github.io/notes/archive/disch/ch-1/",
	"title": "1. Inleiding",
	"tags": [],
	"description": "",
	"content": "Table of contents Herhaling implementatieplatformen FPGA vs. microprocessor Codevoorbeeld Herhaling implementatieplatformen Discrete logica: digitale schakelingen opgebouwd met bijvoorbeeld chips uit de 74-reeks.\nMicroprocessor: vaste hardware waarop software wordt uitgevoerd, zoals bijvoorbeeld de ATmega328-processor op het Arduino Uno-bord.\nASIC (Application Specific Integrated Circuit): vaste hardware met een specifieke functie.\nFPGA (Field-Programmable Gate Array): configureerbare hardware met een regelmatige structuur, waarop specifieke functies geïmplementeerd kunnen worden.\nFPGA vs. microprocessor FPGA Bouwblokken van de FPGA CLB: Configurable Logic Block SM: Switch Matrix IOB: Input/Output Block Basisblokken van een CLB FF: Flip-Flop Mutex: Multiplexer LUT: Look-Up Table Kan geconfigureerd worden tot eender welke functie met 4 ingangen en 1 uitgang. Microprocessor De CPU is het hart van een microprocessor en bevat o.a.:\nALU: Arithmatic Logic Unit Register file Programmageheugen Codevoorbeeld We beschouwen een stukje code in een hardwarebeschrijvingstaal (VHDL) en in een programmeertaal (C).\nHet input-outputgedrag van de implementatie is functioneel hetzelfde. De implementatie gebeurt op een volledig andere manier op een FPGA dan op de microprocessor In zowel VHDL als C zijn a en z bytes, in VHDL is sel een bit en in C is sel een byte if sel = \u0026#39;1\u0026#39; then z \u0026lt;= a sll 1; else z \u0026lt;= a srl 1; end if; if((sel \u0026amp; 0x01) == 1) { z = a \u0026lt;\u0026lt; 1; } else { z = a \u0026gt;\u0026gt; 1; } Beide codefragmenten implementeren een schuifbewerking naar links als de selectiebit gelijk is aan 1 en anders een schuifbewerking naar rechts. Dus ofwel wordt:\nz7z6z5z4z3z2z1z0 = a6a5a4a3a2a1a00 (links) z7z6z5z4z3z2z1z0 = 0a7a6a5a4a3a2a1 (rechts) VHDL → FPGA Er zijn er 2 hardware equivalenten van toepassing:\nEen schuifbewerking is het verbinden van in- en uitgangen met elkaar op een verschoven manier. Kiezen tussen 2 mogelijke waarden op basis van een selectiebit is een multiplexer Hiervoor zijn 8 multiplexers nodig om de 8 bits van z aan te sturen. Om dit op een FPGA te configureren zullen er dus 8 LUT\u0026rsquo;s gebruikt worden zonder FF.\nDe 6 middenste LUT\u0026rsquo;s implementeren een multiplexer. De bovenste en onderste LUT\u0026rsquo;s implementeren een functie die ofwel 0 ofwel de inkomende ai doorlaat op basis van de selectiebit. De LUT\u0026rsquo;s in de CLB\u0026rsquo;s worden verbonden met de juiste in- en uitgangen via Switch Matrices.\nDe LUT\u0026rsquo;s zijn op onderstaande manier geconfigureerd:\nBovenste LUT = bovenste multiplexer: A B C D LUT-out 0 0 x x 0 0 1 x x 0 1 0 x x 1 1 1 x x 0 Middelste LUT (6x) = middelste multiplexer (6x) A B C D LUT-out 0 0 0 x 0 0 0 1 x 0 0 1 0 x 1 0 1 1 x 0 1 0 0 x 0 1 0 1 x 1 1 1 0 x 1 1 1 1 x 1 Onderste LUT = onderster multiplexer A B C D LUT-out 0 0 x x 0 0 1 x x 0 1 0 x x 0 1 1 x x 1 C → microprocessor Het schuiven van bits in een microprocessor gebeurt in de ALU via een schuifbewerking. De schuifinstructies met bijhorende machinecode zien er als volgt uit:\nLogical Shift Left (LSL): De byte op adres Rd = ddddd wordt 1 bit naar links geschoven en daarna terug geschreven op hetzelfde adres. De opcode komt overeen met een optelling van 2 dezelfde getallen. Logical Shift Right (LSR): De byte op adres Rd = ddddd wordt 1 bit naar rechts geschoven en daarna terug geschreven op hetzelde adres. Het controleren of een byte gelijk is aan een constante waarde gebeurt in de ALU via een aftrekking. Als die aftrekking in 0 resulteert, is de byte gelijk aan de constante waarde en anders niet. De zero-flag aan de uitgang van de ALU geeft dus het resultaat weer. Een volgende instructie kan dan de zero-flag controleren om te kiezen tussen de volgende instructie in het programmageheugen of een instructie ergens anders in het programmageheugen.\nCompare with Immediate (CPI): De Waarde KKKKKKKK wordt afgetrokken van de byte op adres Rd = 1dddd; waarbij de zero-flag al dan niet 1 wordt. Branch if Equal (BREQ): Als de zero-flag gelijk is aan 0, springt de program counter 1 plaats verder. Als de zero-flag gelijk is aan 1, springt de program counter kkkkkkk+1 plaatsen verder. Vermits we alle bewerkingen op bytes uitvoeren, moeten we een bit isoleren uit een byte om met 1 selectiebit te werken. We gebruiken een bitmask om 1 bit te selecteren. Dat doen we door een AND-bewerking uit te voeren met een constante byte die uit zeven 0-en en één 1 bestaat. De plaats van de 1 bepaalt welke bit we willen gebruiken.\nIn dit voorbeeld zouden het programmageheugen, de register file en de zero-flag er als volgt kunnen uitzien:\nProgrammageheugen 0 0111000001000001 ANDI r20, 1 1 0011000001000001 CPI r20, 1 2 1111000000011001 BREQ 3 3 1001010000000110 LSR r0 \u0026hellip; 6 0000110000000000 LSL r0 Geef aan hoe onderstaand codevoorbeeld kan omgezet worden in een implementatie op een FPGA en een microprocessor, waarbij c, d en z bytes zijn en waarbij sel een bit is in de VHDL-code en een byte is in C-code. Geeft aan hoe de LUT\u0026rsquo;s geconfigureerd zijn in de FPGA-implementatie. Geef aan wat er in het programmageheugen en de register file zit in de microprocessorimplementatie. Gebruik de AVR-instructieset om de gepaste instructies te vinden. if sel = \u0026#39;1\u0026#39; then z \u0026lt;= c and d; else z \u0026lt;= c or d; end if; if((sel \u0026amp; 0x80) == 0x80) { z = c \u0026amp; d; } else { z = c | d; } "
},
{
	"uri": "https://maarteng18.github.io/notes/archive/disch/ch-2/",
	"title": "2. Progammeerbare logica",
	"tags": [],
	"description": "",
	"content": "Table of contents Overzicht programmeerbare componenten FPGA-technologie Overzicht programmeerbare componenten Programmeerbare verbindingen Fuse:\nGesloten verbinding, opent onder grote stroom OTP (One-Time Programmable) Antifuse:\nOpen verbinding, sluit onder hoge spanning OTP SRAM-gebaseerde verbinding:\nPass transistors gecontroleerd door SRAM Volledig CMOS gebaseerd (E)EPROM-gebaseerd:\nFAMOS EPROM technologie (UV- erasable) FLOTOX EEPROM technologie Flash technologie Programmeerbare componenten (Simple) Programmable Logic Device ((S)PLD): Programmable Logic Array (PLA) Programmable Array Logic (PAL) Programmable Read Only Memory (PROM, EPROM, EEPROM) Complex PLD (CPLD) Field Programmable Gate Array (FPGA) SPLD Elke functie kan geraliseerd worden in een \u0026ldquo;Sum Of Products\u0026rdquo; (SOP) vorm. Een SOP vorm kan gerealiseerd worden door INV/AND/OR (of INV/NAND/NAND) De AND/OR gates zijn vooraf gemaakt. Programmeren gebeurt door het maken of verbreken van connecties tussen gates. PLA: Zowel AND als OR arrays zijn programmeerbaar PAL: AND array is programmeerbaar OR arry is vast PROM: Alle mogelijkheden zijn voorzien PLA Gemeenschappelijk gebruik van producttermen Voorbeeld: F0 = A + B\u0026rsquo;C' F1 = AC\u0026rsquo; + AB F2 = B\u0026rsquo;C + AB F3 = B\u0026rsquo;C + A Alle Mogelijke verbindingen zijn beschikbaar voor het programmeren: De niet-gewenste verbindingen worden opgeblazen Sommige technologieën maken verbindingen i.p.v. ze op te blazen.\nConventies PLA\nOm het aantal lijnen te verminderen tekenen we de verschillende ingangen op 1 lijn. Elke ingang wordt geïnverteerd zodat we zowel de niet-geïnverteerde ingang als de geïnverteerde ingang kunnen gebruiken. Voorstelling PLA\nPLA-voorstelling waarbij alle verbindingen gemaakt zijn. PLA-voorstelling voor de implementatie: F0 = AB + A\u0026rsquo;B' F1 = CD\u0026rsquo; + C\u0026rsquo;D Verschil tussen PLA en PAL PAL: OR verbindingen zijn vast\nDe volgorde van de AND termen moeten zo gekozen worden dat ze overeenkomen met de verbindingen in de OR matrix. De AND termen zijn niet herbruikbaar. Dit leidt tot een grotere matrix. Het aantal AND termen per OR is beperkt. Niet alle functies zijn implementeeraar. Enkel het AND vlak moet geprogrammeerd worden. PLA:\nZowel AND als OR verbindingen zijn programmeerbaar. De AND termen zijn herbruikbaar. Zowel het AND als het OR vlak moeten geprogrammeerd worden. Teken een PLA waarin de volgende functies geprogrammeerd zijn: Z1 = A xor B xor C Z2 = A and (B xnor C) 2-1 multiplexer Hoe ziet een PAL eruit waarin deze functies geprogrammeerd zijn? ROM als PLD In tegenstelling tot een PLA is een ROM een structuur met een volledig gecodeerde AND array. Elke mogelijkheid tot het samen nemen van ingangen (adreslijnen) zit erin. Wat is de inhoud van een ROM-geheugen dat de volgende functies realiseert:\nZ1 = A xor B xor C Z2 = A and (B xnor C) 2-1 multiplexer CPLD CPLD = Complex Programmable Logic Device Een CPLD bestaat uit verschillende logische blokken die elk equivalent zijn met een (S)PLD. Deze (S)PLDs worden met elkaar verbonden via een Programmable Interconnect Matrix (PIM). Op deze manier wordt het Si-oppervlak nuttiger gebruikt in vergelijking met een grote PLD. Algemene structuur:\nFPGA-technologie FPGA = Field Programmable Gate Array Array van logische cellen die met elkaar en met de I/O cellen kunnen communiceren Horizontale en verticale verbindingen. FPGA architectuur IOB: Input/Output Block CLB: Configurable Logic Block SM: Switch Matrix Vergelijking CPLD en FPGA CPLD Continue interconnect Verbindingen hebben een vaste vertraging FPGA Gesegmenteerde verbindingen Verbindingen hebben een onvoorspelbare vertraging. Basisbouwblokken in een CLB Basisprincipe van een SM Evolutie van Xilinx FPGA\u0026rsquo;s Configuratie van FPGA\u0026rsquo;s Configuratiedata: bitstream Configuratiegeheugen: (Anti-)fuse: one-time programmable (OTP) Flash: niet-vluchtig SRAM: vluchtig SRAM (vs. flash) configuratiegeheugen: Hogere dichtheid Hoger vermogenverbruik On-board of on-chip niet-vluchtig geheugen nodig om de bitsream op te slaan tijdens power-off Hogere configuratiesnelheid Configuratie van een CLB Configuratiebits Waarom 16 configuratiebits voor een 4-naar-1 LUT?\n216 mogelijke output functies: Z0 = 0 Z1 = A\u0026rsquo;.B\u0026rsquo;.C\u0026rsquo;.D' Z2 = A\u0026rsquo;.B\u0026rsquo;.C\u0026rsquo;.D Z3 = A\u0026rsquo;.B\u0026rsquo;.C' \u0026hellip; Z65280 = A \u0026hellip; Z65535 = 1 A B C D Z0 Z1 Z2 Z3 \u0026hellip; Z65280 \u0026hellip; Z65535 0 0 0 0 0 1 0 1 0 1 0 0 0 1 0 0 1 1 0 1 0 0 1 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 1 1 1 0 1 0 0 0 0 0 1 1 1 0 1 1 0 0 0 0 1 1 1 1 0 0 0 0 0 0 1 1 1 1 0 1 0 0 0 0 1 1 1 1 1 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 1 1 Configuratie van een SM Ontwerp van een digitaal systeem op FPGA Beschrijving van het ontwerp Schematische invoer Invoer via HDL (Hardware Description Language) VHDL (VHSIC HDL) VHSIC = Very High Speed Integrated Circuit Verilog Implementatie van het systeem Bitsream met configuratie-gegevens Na synthese en place \u0026amp; route Inladen van de bitstream Via download kabel (parallel, USB) verbonden met PC Vanuit on-board ROM Ontwerp m.b.v. VHDL Platform-onafhankelijke code Bruikbaar voor alle FPGA\u0026rsquo;s Bruikbaar voor ASIC standaardcel ontwerp Platform-specifiek code Geoptimaliseerd voor een specifiek FPGA Gebruikmakend van specifieke compenenten in een FPGA Bv.: multiplexers, block RAM\u0026hellip; FPGA vendors AMD (Xilinx) en Intel: SRAM-gebaseerde FPGA\u0026rsquo;s Meer dan 2/3 van de FPGA markt Microchip (Microsemi): Flash-gebaseerde FPGA\u0026rsquo;s Specifieke marktsector voor toepassingen met hoge betrouwbaarheid, databeveiliging, laag vermogenverbruik Lattice en Quicklogic: Laag vermogenverbruik Specifieke functionaliteit "
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-2/",
	"title": "2. Transistor configuraties",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/disch/ch-3/",
	"title": "3. Geheugens",
	"tags": [],
	"description": "",
	"content": "Table of contents RAM-geheugens ROM-geheugens Geheugenuitbreiding RAM-geheugens Situering RAM Indeling RAM SRAM (Statische RAM) Eigenschappen: Snel toegangelijk Veel oppervlakte Gebruiksgebied: Cachegeheugen DRAM (Dynamische RAM) Eigenschappen: Hoge densiteit Relatief trage uitlezing Gebruiksgebied: Hoofdgeheugen Massageheugen SRAM Opbouw van een SRAM-cel Het basis geheugenelement is een lus van invertoren. Deze lus moet onderbroken worden om te schrijven (8 transistors nodig). We kunnen deze onderbreking weglaten als de transistors die schrijven meer stroom leveren dan de transistores in de geheugencel. Dit geeft een stroompad tussen voeding en grond, wat zorgt voor een belangrijke opwarming. Gebruik ban transistors met minimale dimensies nMOS heeft een betere geleidbaarheid da pMOS Dubbel gebruik Schrijven Beide lijnen sturen 1 lijn trekt stroom Uitlezen SRAM-geheugenstructuur SRAM adresdecoder Om een woordlijn te selecteren, gaan we: Niet alle woordlijnen extern doorgeven Wel het nummer van de woordlijn Bv.: 64 woordlijnen Adres is een 6-bit getal 6 adreslijnen nodig De omzetting van het adres naar de overeenstemmende woordlijnen gebeurt in de adresdecoder, hoe meer bits het adres bevat: Hoe groter de decoder Hoe trager de decoder SRAM-organisatie In- en uitgangen:\nCS = Chip Select (actief laag) WE = Write Enable (actief laag) 10 adreslijnen 4 bi-directionele datalijnen SRAM-timing Vereenvoudigde read timing:\nVereenvoudigde write timing:\nBattery back-up RAM is per definite vluchtig\nZodra de spanning wegvalt, gaat de inhoud van het geheugen verloren. Batterij kan ervoor zorgen dat de inhoud toch niet verloren gaat. De batterij kan zelfs ingebouwd worden in de IC-behuizing. ROM-geheugens Opbouw van een DRAM-cel Geheugenelement = 1 tranistor (+ capiciteit) Lezen: laad bitlijn vooraf op tot vaste spanning, stuur woordlijn, meet bitlijn Schrijven: stuur bitlijn, stuur woordlijn Read-out is destructief Refresh cyclus nodig, want opslag verdwijnt op minder dan een ms. Een intern circuit leest het woord en schrijft het terug. Situering ROM Masker ROM met diodes Er worden overal diodes geplaatst Het masker bepaalt welke diodes verbonden worden Dit is veruit de meest eenvoudige wijze om een masker ROM te maken.\nAlle data lijnen zijn via een weerstand met de voeding verbonden. Uitgangen van de decoder zijn in rust verbonden met de voedingsspanning. Het zijn actief lage signalen, zoals aangegeven door het driehoekje aan de uitgang. Over de diodes staat geen spanning en er loopt ook geen stroom. Wanneer er een adres aangelegd wordt aan de ingang van de decoder: Zal de overeenkomstige woordlijn laag worden (0V). Als gevolg hiervan gaan de diodes die met deze woordlijn verbonden zijn geleiden, waarbij de stroom niet bepaald wordt door de diode maar door de weerstand die ermee in serie staat. Aan de uitgangen (D3…D0) hebben we dus typisch 0,7V of VCC, afhankelijk van het feit of er al dan niet een diode aanwezig is. Deze 0,7V ligt onder de drempelspanning van het hierop volgende circuit zodat ze als een digitale 0 herkend wordt. De diodes staan dus op de plaatsen waar er een 0 aanwezig moet zijn in het geheugen. Het is belangrijk op te merken dat er een DC stroom vloeit tussen de voedingsspanning en de uitgangen van de decoder, waardoor de decoder zwaar belast wordt. Een ROM geheugen dat op deze manier geïmplementeerd is, zal dus veel vermogen verbruiken.\nMasker ROM met transistors Een masker ROM kan ook met transistors worden uitgevoerd De decoder wordt hierdoor niet belast. We kunnen in de voorgaande schakeling de diodes vervangen door transistors. Hierdoor moet de decoder niet meer die belangrijke stroom leveren. De stroom van de decoder is beperkt tot de laadstroom van de gate capaciteiten van de transistors. Er blijft nog steeds een DC-stroom lopen, maar deze loopt van de voeding naar de grond via de transistors.\nMerk op dat de uitgang van de decoder in deze schakeling actief hoog is.\nMasker ROM met precharge De precharge zorgt ervoor dat er geen DC-stroom door de bitlijnen loopt. De bitlijnen worden telkens geprecharged vooraleer de decoder wordt uitgelezen. PROM PROM = Programmable ROM Het geheugen kan geprogrammeerd worden door bepaalde fuses/antifuses op te blazen. Er is geen specifiek masker nodig bij de productie. Programmeren gebeurt door hoge spanningspulsen aan te leggen (hogere spanning bij normale werking). EPROM FAMOS technologie Erasable Programmable ROM FAMOS = FLoating gate Avalanche injection MOS transistor UV-wisbaar Een FAMOS transistor is uitgevoerd met een dubbele gate.\nDe bovenste gate is verbonden met de woordlijn. De onderste gate is echter met niets verbonden en is dus zwevend. In normale omstandigheden is er geen lading aanwezig op de onderste gate. Wanneer er echter, door het aanleggen van een hogere voedingsspanning aan de gate, langdurig een zeer grote stroom tussen source en drain getrokken wordt, gaan er elektronen zijn die door botsingen een voldoende grote energie bekomen om in staat te zijn over het oxide heen te vliegen (lawine-effect). In dit geval wordt de zwevende gate opgeladen met elektronen.\nTijdens de normale werking van deze nMOS transistor in FAMOS technologie leggen we een positieve spanning aan aan de bovenste gate. Dit zorgt voor een positieve lading op de bovenste gate en een kanaal van elektronen onder de gates waardoor de transistor geleidt. Wanneer de zwevende gate echter is opgeladen met elektronen zal de positieve lading op de bovenste gate gecompenseerd worden door de elektronenlading op de zwevende gate en bekomen we geen elektronen meer in het kanaal tussen source en drain. De transistor zal dus niet geleiden.\nDe lading van de zwevende gate kan verdwijnen als de ladingsdragers voldoende energie krijgen. Dit kan m.b.v. UV-licht.\nEPROM Het programmeren van het geheugen gebeurt in een speciale EPROM-programmer. Het wissen gebeurt a.d.h.v. UV-licht.\nIn een EPROM geheugen is er een FAMOS transistor aanwezig op elke positie. Door het aanleggen van een hogere voedingsspanning kan er gekozen worden welke transistors niet mogen geleiden. Het hele geheugen kan gewist worden m.b.v. UV-licht. Het is niet mogelijk om enkel specifieke geheugenplaatsen te wissen.\nFLOTOX EEPROM technologie EEPROM = Electrically Erasable Programmable ROM FLOTOX = Floating gate Tunnel Oxide Er wordt gebruik gemaakt van een dun oxide. Op die manier is er geen UV-licht nodig om te wissen, het wissen gebeurt elektrisch (in-circuit programming). Een EEPROM maakt gebruik van het doortunneleffect om een zwevende gate op te laden. Er is een dun oxide voorzien boven de drain van de transistor. De elektronen gaan doortunnelen naar de zwevende gate wanneer er een voldoende hoge spanning wordt aangelegd aan de bovenste gate.\nEen belangrijk voordeel van het opladen van de zwevende gate door doortunnelen, is dat dit principe ook omkeerbaar is, zodat een EEPROM elektrisch kan gewist worden. Het wissen gebeurt door een spanning aan te leggen tussen drain en source zonder de bovenste gate op te laden. De elektronen tunnelen dan terug door het dunne oxide. Het gevolg hiervan is wel dat tijdens het gebruik van het geheugen de bovenste gate steeds moet verbonden zijn met de voedingsspanning om ervoor te zorgen dat de elektronen niet terug doortunnelen naar de drain. De woordlijntransistor en de programmeertransistor kunnen dus niet meer dezelfde zijn. Daarom hebben we voor een EEPROM geheugen een tweede transistor nodig per geheugenelement.\nFLASH geheugen Vergelijkbaar met EEPROM Veel sneller en compacter dan EEPROM, omdat het wissen en herprogrammeren in grote blokken gebeurt. Niet-vluchtig RAM Combinatie van SRAM (snel) EEPROM (traag) Onder normale werking: SRAM Een \u0026ldquo;store\u0026rdquo;-bevel slaat alles op in de EEPROM Een \u0026ldquo;recall\u0026rdquo;-bevel haalt alles uit de EEPROM Wanneer de voedingsspanning wegvalt, kan een \u0026ldquo;power failure\u0026rdquo; schakelingen dit selecteren en tijdig een \u0026ldquo;store\u0026rdquo;-bevel geven. Geheugenuitbreiding Het principe van geheugenuitbreiding is van toepassing op zowel ROM- als RAM-geheugens\nUitbreiding van de woordbreedte: Het aantal bereikbare adressen blijft gelijk Het aantal bits per adres wordt uitgebreid Uitbreiding van het adresbereik: Het aantal bits per adres blijven gelijk Het aantal bereikbare adressen worden uitgebreid Uitbreiding van de woordbreedte (voorbeeld) We vertrekken van twee ROM IC\u0026rsquo;s met een adres van 10 bits (dus een adresbereik van 210 adressen) en een woordbreedte van 4 bits. Beide IC\u0026rsquo;s krijgen hetzelfde adres. Beide IC\u0026rsquo;s produceren 4 bits van de data. In totaal zijn er 8 databits beschikbaar. Uitbreiding van het adresbereik (voorbeeld) We vertrekken van dezelfde 2 IC\u0026rsquo;s. Beide IC\u0026rsquo;s krijgen de 10 minst beduidende adreslijnen. De 11de adreslijn wordt gebruikt voor de \u0026ldquo;chip select\u0026rdquo;. De 4 data bits komen van 1 van de 2 chips. Geheugenmodules Per module staan een aantal IC\u0026rsquo;s georganiseerd volgens het principe van het uitbreiden van de woordbreedte. Indien de woordbreedte van de module kleiner is dan de breedte van de databus, moeten meerdere modules gelijktijdig gebruikt worden zodat de woordbreedte kan worden uitgebreid tot de breedte van een databus. Deze combinatie noemen we een geheugenbank. Meerdere geheugenbanken kunnen gecombineerd worden voor het uitbreiden van het adresbereik. Moderne geheugenmodules hebben een woordbreedte die overeenstemt met de breedt van de databus. Startende van geheugenblokken met een woordbreedte van 64 bits en een diepte van 128 woorden:\nTeken het schema van een geheugen met een woordbreedte van 256 bits en een diepte van 128 woorden. Teken het schema van een geheugen met een woordbreedte van 64 bits en een diepte van 256 woorden. Teken het schema van een geheugen met een woordbreedte van 256 bits en een diepte van 512 woorden. "
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-3/",
	"title": "3. Klasse A versterker",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-4/",
	"title": "4. Klasse B versterker",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/disch/ch-4/",
	"title": "4. Ontwerpprincipes voor synchrone logica",
	"tags": [],
	"description": "",
	"content": "Table of contents Voorbeeld ter introductie Ontwerpvoorbeeld: AES Voorbeeld ter introductie Kleren worden gewassen in 3 stappen:\n1 wasmand verwerken Het verwerken van 1 wasmand duurt 1 uur Throughput = 1 wasmand/uur Latency per wasmand = 1 uur 3 wasmanden verwerken Het verwerken van 3 wasmanden duurt 3 uren als we de wasmanden 1 voor 1 volledig verwerken Throughput = 1 wasmand/uur Latency per wasmand = 1 uur Verhogen van de throughput Parallellisatie Elke machine wordt 3x voorzien Het verwerken van 3 wasmanden duurt 1 uur Throughput = 3 wasmanden/uur Latency per wasmand = 1 uur Pipelining Throughput = 3 wasmanden/uur (na de opstartfase) Latency per wasmand = 1 uur Wat als het proces meerdere keren wordt doorlopen Stel dat een wasmand 3 keer na mekaar het hele proces moet doorlopen. Dan kunnen we geen pipelining gebruiken als elke machine maar 1 keer voorzien is. Loop unrolling Elke machine 3 keer voorzien + pipelining toepassen Ontwerpvoorbeeld: AES Animatie\nLoop architectuur AES: 1 klokcyclus per ronde (parallelle verwerking van 128 bits):\nThroughput = T Oppervlakte = A AES: 16 klokcycli per ronde (verwerking byte-per-byte):\nThroughput ≈ T/16 Oppervlakte \u0026gt; A/16 Loop unrolling Loop unrolling zonder pipelining: throughput = T, oppervlakte ≈ 10 * A\nLoop unrolling met pipelining: throughput ≈ 10 * T, oppervlakte ≈ 10 * A\n"
},
{
	"uri": "https://maarteng18.github.io/notes/archive/disch/ch-5/",
	"title": "5. Simulatie",
	"tags": [],
	"description": "",
	"content": "Table of contents Testbenches Evalutie van een hardware-ontwerp Testbenches Doelstelling van testbenches Het testen van VHDL code (of delen van code) zodat de juiste werking kan getest worden voordat de code geïmplementeerd wordt in een hardware component. Het definiëren van een omgeving die in eens testmachine kan gebruikt worden om een bestaande component te testen. Een elektronisch ontwerp maken op zich volstaat niet. Bij een goed ontwerp bestaat minstens 50 % van de ontwerptijd uit het uitdenken en uitwerken van testen die verzekeren dat het ontwerp functioneert zoals het moet. Deze testen dienen zowel te gebeuren tijdens de verschillende iteraties en verbeteringen van het ontwerp als na de uiteindelijke realisatie. Het is ook goed om eerst de verschillende deelblokken uitvoerig en volledig te testen en pas daarna (als alle deelblokken correct werken) het geheel te testen. Het vlug wat signalen aanleggen nadat de VHDL code klaar is en het vlug even kijken of de uitgangssignalen zijn zoals we denken dat ze moeten zijn, volstaat duidelijk niet en is de foutieve aanpak.\nVoordelen van testbenches In een testbench kan je systematisch alle te voorziene situaties implementeren, zodat je de zekerheid hebt dat de component onder alles omstandigheden zal werken. Bij complexe systemen kan je niet manueel alle mogelijkheden testen. Debuggen kan gebeuren zonder de component in werkelijkheid te moeten programmeren. Bij een goed ontwerp zullen we gelijktijdig met het ontwerp (of zelfs vooraf) ook de testen waaraan het ontwerp dient te voldoen schrijven. Deze testen worden ook in VHDL beschreven en elke keer dat we het ontwerp testen, zullen we dat doen aan de hand van dezelfde testbench.\nImplementatie Een nieuw bouwblok (van een hoger niveau) wordt gecreëerd. Deze bouwblok gebruikt de te testen blok (DUR of Device Under Test) als component: Ingangssignalen worden hieraan aangelegd Uitgangssignalen worden opgemeten De verschillen tussen wat verwacht wordt en wat bekomen wordt, worden gerapporteerd. Naar het scherm toe Naar een tekstfile Basisstructuur van een testbench De entity van de testbench bevat geen port. De architecture vangt aan met de declaratie van alle input en output signalen van de DUT en eventueel ook de declaratie van ee log-file om resultaten in weg te schrijven. De component die moet getest worden, wordt vervolgens gedeclareerd. entity testbench is end testbench; architecture test of tesbench is signal in0,in1,in2,in3: bit; signal output: bit; component te_testen port(in0, in1, in2, in3: in bit; output: out bit); end component; In de body van de architectuur (na begin instructie) staat vervolgens de instantiatie van de resten component. Daarna volgen processen die inputs aanleggen of outputs wegschrijven. begin dut: te_testen port map(in0, in1, in2, in3, output); process begin in0 \u0026lt;= \u0026#39;1\u0026#39;; in1 \u0026lt;= \u0026#39;0\u0026#39; after 1 ns; wait for 10 ns; in2 \u0026lt;= \u0026#39;0\u0026#39;; in3 \u0026lt;= \u0026#39;1\u0026#39; after 1 ns; wait for 10 ns; in0 \u0026lt;= \u0026#39;0\u0026#39;; in1 \u0026lt;= \u0026#39;1\u0026#39; after 1 ns; wait for 10 ns; in2 \u0026lt;= \u0026#39;1\u0026#39;; in3 \u0026lt;= \u0026#39;0\u0026#39; after 1 ns; wait for 10 ns; end process; Kloksignaal in een testbench De klok-periode kan als constant gedaclareerd worden CONSTANT clk_period = time := 10 ns; De klok kan gegenereerd worden door een speciaal proces. clk_process: process begin clk \u0026lt;= \u0026#39;0\u0026#39;; wait for clk_period/2; clk \u0026lt;= \u0026#39;1\u0026#39;; wait for clk_period/2; end process; Berichten in een testbench De assert instructie laat toe berichten mee te delen. De assert instructie wordt gevolgd door een booleaanse expressie. Als aan deze expressie niet voldaan is wordt een \u0026ldquo;assetion violation\u0026rdquo; gerapporteerd. (default) assert (out = (in1 and in2)); Je kan hetgeen gerapporteerd wordt aanpassen met een report keyword Na de report moet altijd een string volgen. assert (out = (in1 and in2)) report \u0026#34;De and-poort werkt niet\u0026#34;; De report kan ook los staan. report \u0026#34;Ik ben nu in deze lus\u0026#34;; De ernst van het bericht kan je aanpassen met het severity keyword. De ernst die hierop volgt moet van het type severity_level zijn. Je kan bepalen bij welke erns de simulator moet stoppen. assert (out = (in1 and in2)) report \u0026#34;Fout\u0026#34; severity ERROR; type severity_level is (note, warning, error, failure); Evalutie van een hardware-ontwerp Maximale klokfrequentie = 1/(vertraging van het kritisch pad) Bepaling van de maximale klokfrequentie door de tools: Leg een bepaalde klokfrequentie op. Check via de ontwerptools of de opgelegde frequentie kan gehaald worden. Indien niet: herhaal met een lagere klokfrequentie Indien wel: herhaal met een hogere klokfrequentie De maximale klokfrequentie is gelijk aan de hoogste klokfrequentie waarover de tools rapporteren dat ze gehaald kan warden. "
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-5/",
	"title": "5. voedingen",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-6/",
	"title": "6. GaN transistor toepassingen",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-7/",
	"title": "7. Thyristors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-8/",
	"title": "8. Berekening van elektronische circuits",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-9/",
	"title": "9. Niet-lineaire OpAMP schakelingen",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/scripts-commands/imagemagick/montage/",
	"title": "Montage",
	"tags": [],
	"description": "",
	"content": "Paste images underneath eachother With this command you can paste images underneath eachother into a montage.\nmontage [1-3].PNG -tile 1 -geometry 500x300+1+1 combo.png\n"
},
{
	"uri": "https://maarteng18.github.io/notes/scripts-commands/markdown/notices/",
	"title": "Notices",
	"tags": [],
	"description": "",
	"content": "Note {{% notice note %}} A notice disclaimer {{% /notice %}} renders as\nA notice disclaimer\n{{% notice todolist %}} A notice disclaimer {{% /notice %}} renders as\nA notice disclaimer\n{{% notice summary %}} A notice disclaimer {{% /notice %}} renders as\nA notice disclaimer\n{{% notice info %}} A notice disclaimer {{% /notice %}} renders as\nA notice disclaimer\n{{% notice tip %}} A notice disclaimer {{% /notice %}} renders as\nA notice disclaimer\n{{% notice warning %}} A notice disclaimer {{% /notice %}} renders as\nA notice disclaimer\n"
},
{
	"uri": "https://maarteng18.github.io/notes/archive/ansch/ch-10/",
	"title": "10. OTA schakelingen",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://maarteng18.github.io/notes/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]