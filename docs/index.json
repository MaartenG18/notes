[
{
	"uri": "https://maarteng18.github.io/notes/courses/",
	"title": "Courses",
	"tags": [],
	"description": "",
	"content": "Current courses Analoge Elektronische Schakelingen Digitale Elektronische Schakelingen Android App Development Besturingssystemen en C Software Engineering Skills "
},
{
	"uri": "https://maarteng18.github.io/notes/",
	"title": "Maarten&#39;s notes",
	"tags": [],
	"description": "",
	"content": "Maarten\u0026rsquo;s notes Current courses Analoge Elektronische Schakelingen Digitale Elektronische Schakelingen Android App Development Besturingssystemen en C Software Engineering Skills Good to know I\u0026rsquo;m currently making a portfolio, more coming soon\nSome usefull commands ImageMagick "
},
{
	"uri": "https://maarteng18.github.io/notes/scripts-commands/",
	"title": "Scripts &amp; commands",
	"tags": [],
	"description": "",
	"content": "Subjects ImageMagick "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/ansch/",
	"title": "Analoge Elektronische Schakelingen",
	"tags": [],
	"description": "",
	"content": "Chapters Herhaling MOSFET en BJT "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/disch/",
	"title": "Digitale Elektronische Schakelingen",
	"tags": [],
	"description": "",
	"content": "Chapters Inleiding Programmeerbare logica Geheugens Ontwerpprincipes voor synchrone logica Simulatie "
},
{
	"uri": "https://maarteng18.github.io/notes/scripts-commands/imagemagick/",
	"title": "Image Magick",
	"tags": [],
	"description": "",
	"content": "Subjects Montage "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/ansch/ch-1/",
	"title": "1. Herhaling MOSFET en BJT",
	"tags": [],
	"description": "",
	"content": "MOSFET BJT "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/disch/ch-1/",
	"title": "1. Inleiding",
	"tags": [],
	"description": "",
	"content": "Table of contents Herhaling implementatieplatformen FPGA vs. microprocessor Codevoorbeeld Herhaling implementatieplatformen Discrete logica: digitale schakelingen opgebouwd met bijvoorbeeld chips uit de 74-reeks.\nMicroprocessor: vaste hardware waarop software wordt uitgevoerd, zoals bijvoorbeeld de ATmega328-processor op het Arduino Uno-bord.\nASIC (Application Specific Integrated Circuit): vaste hardware met een specifieke functie.\nFPGA (Field-Programmable Gate Array): configureerbare hardware met een regelmatige structuur, waarop specifieke functies geïmplementeerd kunnen worden.\nFPGA vs. microprocessor FPGA Bouwblokken van de FPGA CLB: Configurable Logic Block SM: Switch Matrix IOB: Input/Output Block Basisblokken van een CLB FF: Flip-Flop Mutex: Multiplexer LUT: Look-Up Table Kan geconfigureerd worden tot eender welke functie met 4 ingangen en 1 uitgang. Microprocessor De CPU is het hart van een microprocessor en bevat o.a.:\nALU: Arithmatic Logic Unit Register file Programmageheugen Codevoorbeeld We beschouwen een stukje code in een hardwarebeschrijvingstaal (VHDL) en in een programmeertaal (C).\nHet input-outputgedrag van de implementatie is functioneel hetzelfde. De implementatie gebeurt op een volledig andere manier op een FPGA dan op de microprocessor In zowel VHDL als C zijn a en z bytes, in VHDL is sel een bit en in C is sel een byte if sel = \u0026#39;1\u0026#39; then z \u0026lt;= a sll 1; else z \u0026lt;= a srl 1; end if; if((sel \u0026amp; 0x01) == 1) { z = a \u0026lt;\u0026lt; 1; } else { z = a \u0026gt;\u0026gt; 1; } Beide codefragmenten implementeren een schuifbewerking naar links als de selectiebit gelijk is aan 1 en anders een schuifbewerking naar rechts. Dus ofwel wordt:\nz7z6z5z4z3z2z1z0 = a6a5a4a3a2a1a00 (links) z7z6z5z4z3z2z1z0 = 0a7a6a5a4a3a2a1 (rechts) VHDL -\u0026gt; FPGA Er zijn er 2 hardware equivalenten van toepassing:\nEen schuifbewerking is het verbinden van in- en uitgangen met elkaar op een verschoven manier. Kiezen tussen 2 mogelijke waarden op basis van een selectiebit is een multiplexer Hiervoor zijn 8 multiplexers nodig om de 8 bits van z aan te sturen. Om dit op een FPGA te configureren zullen er dus 8 LUT\u0026rsquo;s gebruikt worden zonder FF.\nDe 6 middenste LUT\u0026rsquo;s implementeren een multiplexer. De bovenste en onderste LUT\u0026rsquo;s implementeren een functie die ofwel 0 ofwel de inkomende ai doorlaat op basis van de selectiebit. De LUT\u0026rsquo;s in de CLB\u0026rsquo;s worden verbonden met de juiste in- en uitgangen via Switch Matrices.\nDe LUT\u0026rsquo;s zijn op onderstaande manier geconfigureerd:\nBovenste LUT = bovenste multiplexer: A B C D LUT-out 0 0 x x 0 0 1 x x 0 1 0 x x 1 1 1 x x 0 Middelste LUT (6x) = middelste multiplexer (6x) A B C D LUT-out 0 0 0 x 0 0 0 1 x 0 0 1 0 x 1 0 1 1 x 0 1 0 0 x 0 1 0 1 x 1 1 1 0 x 1 1 1 1 x 1 Onderste LUT = onderster multiplexer A B C D LUT-out 0 0 x x 0 0 1 x x 0 1 0 x x 0 1 1 x x 1 C -\u0026gt; microprocessor Het schuiven van bits in een microprocessor gebeurt in de ALU via een schuifbewerking. De schuifinstructies met bijhorende machinecode zien er als volgt uit:\nLogical Shift Left (LSL): De byte op adres Rd = ddddd wordt 1 bit naar links geschoven en daarna terug geschreven op hetzelfde adres. De opcode komt overeen met een optelling van 2 dezelfde getallen. Logical Shift Right (LSR): De byte op adres Rd = ddddd wordt 1 bit naar rechts geschoven en daarna terug geschreven op hetzelde adres. Het controleren of een byte gelijk is aan een constante waarde gebeurt in de ALU via een aftrekking. Als die aftrekking in 0 resulteert, is de byte gelijk aan de constante waarde en anders niet. De zero-flag aan de uitgang van de ALU geeft dus het resultaat weer. Een volgende instructie kan dan de zero-flag controleren om te kiezen tussen de volgende instructie in het programmageheugen of een instructie ergens anders in het programmageheugen.\nCompare with Immediate (CPI): De Waarde KKKKKKKK wordt afgetrokken van de byte op adres Rd = 1dddd; waarbij de zero-flag al dan niet 1 wordt. Branch if Equal (BREQ): Als de zero-flag gelijk is aan 0, springt de program counter 1 plaats verder. Als de zero-flag gelijk is aan 1, springt de program counter kkkkkkk+1 plaatsen verder. Vermits we alle bewerkingen op bytes uitvoeren, moeten we een bit isoleren uit een byte om met 1 selectiebit te werken. We gebruiken een bitmask om 1 bit te selecteren. Dat doen we door een AND-bewerking uit te voeren met een constante byte die uit zeven 0-en en één 1 bestaat. De plaats van de 1 bepaalt welke bit we willen gebruiken.\nIn dit voorbeeld zouden het programmageheugen, de register file en de zero-flag er als volgt kunnen uitzien:\nProgrammageheugen 0 0111000001000001 ANDI r20, 1 1 0011000001000001 CPI r20, 1 2 1111000000011001 BREQ 3 3 1001010000000110 LSR r0 \u0026hellip; 6 0000110000000000 LSL r0 Geef aan hoe onderstaand codevoorbeeld kan omgezet worden in een implementatie op een FPGA en een microprocessor, waarbij c, d en z bytes zijn en waarbij sel een bit is in de VHDL-code en een byte is in C-code. Geeft aan hoe de LUT\u0026rsquo;s geconfigureerd zijn in de FPGA-implementatie. Geef aan wat er in het programmageheugen en de register file zit in de microprocessorimplementatie. Gebruik de AVR-instructieset om de gepaste instructies te vinden. if sel = ‘1’ then z \u0026lt;= c and d; else z \u0026lt;= c or d; end if; if((sel \u0026amp; 0x80) == 0x80) { z = c \u0026amp; d; } else { z = c | d; } "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/disch/ch-2/",
	"title": "2. Progammeerbare logica",
	"tags": [],
	"description": "",
	"content": "Table of contents Overzicht programmeerbare componenten FPGA-technologie Overzicht programmeerbare componenten Programmeerbare verbindingen Fuse:\nGesloten verbinding, opent onder grote stroom OTP (One-Time Programmable) Antifuse:\nOpen verbinding, sluit onder hoge spanning OTP SRAM-gebaseerde verbinding:\nPass transistors gecontroleerd door SRAM Volledig CMOS gebaseerd (E)EPROM-gebaseerd:\nFAMOS EPROM technologie (UV- erasable) FLOTOX EEPROM technologie Flash technologie Programmeerbare componenten (Simple) Programmable Logic Device ((S)PLD): Programmable Logic Array (PLA) Programmable Array Logic (PAL) Programmable Read Only Memory (PROM, EPROM, EEPROM) Complex PLD (CPLD) Field Programmable Gate Array (FPGA) SPLD Elke functie kan geraliseerd worden in een \u0026ldquo;Sum Of Products\u0026rdquo; (SOP) vorm. Een SOP vorm kan gerealiseerd worden door INV/AND/OR (of INV/NAND/NAND) De AND/OR gates zijn vooraf gemaakt. Programmeren gebeurt door het maken of verbreken van connecties tussen gates. PLA: Zowel AND als OR arrays zijn programmeerbaar PAL: AND array is programmeerbaar OR arry is vast PROM: Alle mogelijkheden zijn voorzien PLA Gemeenschappelijk gebruik van producttermen Voorbeeld: F0 = A + B\u0026rsquo;C' F1 = AC\u0026rsquo; + AB F2 = B\u0026rsquo;C + AB F3 = B\u0026rsquo;C + A Alle Mogelijke verbindingen zijn beschikbaar voor het programmeren: De niet-gewenste verbindingen worden opgeblazen Sommige technologieën maken verbindingen i.p.v. ze op te blazen.\nConventies PLA\nOm het aantal lijnen te verminderen tekenen we de verschillende ingangen op 1 lijn. Elke ingang wordt geïnverteerd zodat we zowel de niet-geïnverteerde ingang als de geïnverteerde ingang kunnen gebruiken. Voorstelling PLA\nPLA-voorstelling waarbij alle verbindingen gemaakt zijn. PLA-voorstelling voor de implementatie: F0 = AB + A\u0026rsquo;B' F1 = CD\u0026rsquo; + C\u0026rsquo;D Verschil tussen PLA en PAL PAL: OR verbindingen zijn vast\nDe volgorde van de AND termen moeten zo gekozen worden dat ze overeenkomen met de verbindingen in de OR matrix. De AND termen zijn niet herbruikbaar. Dit leidt tot een grotere matrix. Het aantal AND termen per OR is beperkt. Niet alle functies zijn implementeeraar. Enkel het AND vlak moet geprogrammeerd worden. PLA:\nZowel AND als OR verbindingen zijn programmeerbaar. De AND termen zijn herbruikbaar. Zowel het AND als het OR vlak moeten geprogrammeerd worden. Teken een PLA waarin de volgende functies geprogrammeerd zijn: Z1 = A xor B xor C Z2 = A and (B xnor C) 2-1 multiplexer Hoe ziet een PAL eruit waarin deze functies geprogrammeerd zijn? ROM als PLD In tegenstelling tot een PLA is een ROM een structuur met een volledig gecodeerde AND array. Elke mogelijkheid tot het samennemen van ingangen (adreslijnen) zit erin. Wat is de inhoud van een ROM-geheugen dat de volgende functies realiseert:\nZ1 = A xor B xor C Z2 = A and (B xnor C) 2-1 multiplexer CPLD CPLD = Complex Programmable Logic Device Een CPLD bestaat uit verschillende logische blokken die elk equivalent zijn met een (S)PLD. Deze (S)PLDs worden met elkaar verbonden via een Programmable Interconnect Matrix (PIM). Op deze manier wordt het Si-oppervlak nuttiger gebruikt in vergelijking met een grote PLD. Algemene structuur:\nFPGA-technologie FPGA = Field Programmable Gate Array Array van logische cellen die met elkaar en met de I/O cellen kunnen communiceren Horizontale en verticale verbindingen. FPGA architectuur IOB: Input/Output Block CLB: Configurable Logic Block SM: Switch Matrix Vergelijking CPLD en FPGA CPLD Continue interconnect Verbindingen hebben een vaste vertraging FPGA Gesegmenteerde verbindingen Verbindingen hebben een onvoorspelbare vertraging. Basisbouwblokken in een CLB Basisprincipe van een SM Evolutie van Xilinx FPGA\u0026rsquo;s Configuratie van FPGA\u0026rsquo;s Configuratiedata: bitstream Configuratiegeheugen: (Anti-)fuse: one-time programmable (OTP) Flash: niet-vluchtig SRAM: vluchtig SRAM (vs. flash) configuratiegeheugen: Hogere dichtheid Hoger vermogenverbruik On-board of on-chip niet-vluchtig geheugen nodig om de bitsream op te slaan tijdens power-off Hogere configuratiesnelheid Configuratie van een CLB Configuratiebits Waarom 16 configuratiebits voor een 4-naar-1 LUT?\n216 mogelijke output functies: Z0 = 0 Z1 = A\u0026rsquo;.B\u0026rsquo;.C\u0026rsquo;.D' Z2 = A\u0026rsquo;.B\u0026rsquo;.C\u0026rsquo;.D Z3 = A\u0026rsquo;.B\u0026rsquo;.C' \u0026hellip; Z65280 = A \u0026hellip; Z65535 = 1 A B C D Z0 Z1 Z2 Z3 \u0026hellip; Z65280 \u0026hellip; Z65535 0 0 0 0 0 1 0 1 0 1 0 0 0 1 0 0 1 1 0 1 0 0 1 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 1 1 1 0 1 0 0 0 0 0 1 1 1 0 1 1 0 0 0 0 1 1 1 1 0 0 0 0 0 0 1 1 1 1 0 1 0 0 0 0 1 1 1 1 1 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 1 1 Configuratie van een SM Ontwerp van een digitaal systeem op FPGA Beschrijving van het ontwerp Schematische invoer Invoer via HDL (Hardware Description Language) VHDL (VHSIC HDL) VHSIC = Very High Speed Integrated Circuit Verilog Implementatie van het systeem Bitsream met configuratie-gegevens Na synthese en place \u0026amp; route Inladen van de bitstream Via download kabel (parallel, USB) verbonden met PC Vanuit on-board ROM Ontwerp m.b.v. VHDL Platform-onafhankelijke code Bruikbaar voor alle FPGA\u0026rsquo;s Bruikbaar voor ASIC standaardcel ontwerp Platform-specifiek code Geoptimaliseerd voor een specifiek FPGA Gebruikmakend van specifieke compenenten in een FPGA Bv.: multiplexers, block RAM\u0026hellip; FPGA vendors AMD (Xilinx) en Intel: SRAM-gebaseerde FPGA\u0026rsquo;s Meer dan 2/3 van de FPGA markt Microchip (Microsemi): Flash-gebaseerde FPGA\u0026rsquo;s Specifieke marktsector voor toepassingen met hoge betrouwbaarheid, databeveiliging, laag vermogenverbruik Lattice en Quicklogic: Laag vermogenverbruik Specifieke functionaliteit "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/disch/ch-3/",
	"title": "3. Geheugens",
	"tags": [],
	"description": "",
	"content": "Table of contents RAM-geheugens ROM-geheugens RAM-geheugens SRAM (Statische RAM) Eigenschappen: Snel toegangelijk Veel oppervlakte Gebruiksgebied: Cachegeheugen DRAM (Dynamische RAM) Eigenschappen: Hoge densiteit Relatief trage uitlezing Gebruiksgebied: Hoofdgeheugen Massageheugen ROM-geheugens "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/disch/ch-4/",
	"title": "4. Ontwerpprincipes voor synchrone logica",
	"tags": [],
	"description": "",
	"content": "Ontwerpprincipes voor synchrone logica "
},
{
	"uri": "https://maarteng18.github.io/notes/courses/disch/ch-5/",
	"title": "5. Simulatie",
	"tags": [],
	"description": "",
	"content": "Simulatie "
},
{
	"uri": "https://maarteng18.github.io/notes/scripts-commands/imagemagick/montage/",
	"title": "Montage",
	"tags": [],
	"description": "",
	"content": "Paste images underneath eachother With this command you can paste images underneath eachother into a montage.\nmontage [1-3].PNG -tile 1 -geometry 500x300+1+1 combo.png\n"
},
{
	"uri": "https://maarteng18.github.io/notes/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]